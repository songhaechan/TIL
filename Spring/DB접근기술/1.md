## JDBC 인터페이스

과거에는 MySQL, Oracle 등 특정 DB벤더에 맞춰 개발자가 직접 코드를 작성했다.

DB가 바뀌면 DB에 관련된 서비스 코드를 모두 손봐야한다.

java는 JDBC로 DB커넥션 기술을 추상화했고, DB벤더는 이 인터페이스에 맞춰 구현체를 개발했다.(DB 드라이버)

## SQL Mapper vs ORM

SQL Mapper

- JDBCTemplate
- Mybatis

DB커넥션, 객체 매핑은 Mapper가 수행하고, SQL만 개발자가 작성

ORM

- JPA (interface)
- Hibernate (구현체)
- Eclipse Link (구현체)

SQL까지도 개발자가 작성하지 않는다.(jpql은 작성함.)

**이 둘의 장단점을 느껴보자.**

그리고 결국 SQLMapper, ORM도 **JDBC**를 사용하니까 잘 알아두자.

## DB Connection Pool

JDBC DriverManager는 사용자의 요청이 들어올 때마다 DB와 TCP/IP (3-way handshaking)연결을 맺고 커넥션을 반환한다.

매번 커넥션을 맺고 끊기엔 네트워크 비용이 과도하게 발생하는 문제가 있다.

그래서 등장한 HikariCP, DBCP2 등은 커넥션을 미리 생성해 TCP/IP연결을 유지한채로 재활용할 수 있는 기술이다.

HikariCP이 전국 통일을 이루었고 Spring도 default로 사용중!!

## Datasource

DriverManager를 통해 매번 커넥션을 생성하는 방법에서 HikariCP로 마이그레이션을 해야한다면 어떻게 해야할까?

커넥션을 얻어오는 방식 자체가 다르기 때문에 코드를 엎어야한다.

항상 이런 문제점들은 추상화로 해결한다.

Datasource라는 인터페이스를 놓고 HikariCP, DBCP2, DriverManager Datasource의 구현체를 바꿔가며 사용할 수 있다.

Datasource는 한 마디로 **커넥션을 획득하는 방법**을 추상화한 것.

## 구현에 대한 추가적 팁

JDBC 커넥션에 관한 설정을 abstract 클래스로 생성해 따로 들고있고, Util 클래스를 생성해 자주 사용하는 static 메서드를 따로 모아두는 것이 설정과 사용의 분리에 좋은 구현.

## HikariCP adder

커넥션 풀에 커넥션을 저장할 때 어플리케이션 스레드로 할당하지 않고 별도의 스레드가 add하게된다. (adder)

왜?

애플리케이션 스레드로 커넥션을 얻는다면 TCP/IP 연결 성공 까지 계속 대기해야하기 때문에 스프링이 뜨는 시간이 오래걸림.

https://github.com/brettwooldridge/HikariCP [공식문서]
