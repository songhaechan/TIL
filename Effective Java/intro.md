Effective Java
==
Effective Java를 읽고 정리하려한다.

1장
==

Subclassing? Subtyping?
--
>이펙티브자바에서 상속을 서브클래싱(subclassing)과 동일한 의미로 기술했다는 내용이나온다. 상속은 들어봤지만 서브클래싱이란 무엇일까?

간단히 말해 Subclassing은 코드의 재사용만을 목적으로하는 상속을 말한다. 

펭귄과 새를 예시로 들어보면자

> 펭귄 : [날개] , [걷기] , [부리] 등등

> 새 : [날개] , [걷기] , [날 수 있음] 등등

펭귄은 새와 공통점이 많지만 펭귄은 날 수가 없다. 하지만 나머지 특성들이 같아서 코드의 재사용을 위해 펭귄이 새를 상속받는 것을 서브클래싱이라고 한다.

개발자는 코드의 재사용만을 위한 상속은 지양하고, 타입계층의 구분을 위한 명확한 상속(Subtyping)을 지향해야한다.

메서드 시그니처
--
메서드의 이름과 입력 매개변수의 타입들로 이뤄진다.

클라이언트와 사용자
--
API를 사용하는 작성자를 API의 사용자라 하고, API를 사용하는 클래스를 그 API의 클라이언트라 한다.

2장
==
item #1 : 생성자 대신 정적 팩터리 메서드를 고려하라
--
public 생성자는 반활될 객체의 특성을 쉽게 파악하기 어렵다. 게다가 매개변수가 늘어나면 매개변수의 특성 또한 알아보기 쉽지않다.

```java
public static Boolean valueOf(boolean b){
    return b ? Boolean.TRUE : Boolean.FALSE
}
```

위는 책에서 제시한 대표적 정적 팩터리메서드다.

생성자를 이용하지않고 매개변수에 boolean을 넘겨주고 객체를 반환받는데, 메서드시그니처로 어떤 객체를 반환받을지 직관적으로 파악이 가능하다.

정적팩터리 메서드의 장단점을 알아보자.

---
**장점**

1. 이름을 가질 수 있다.

    대부분의 생성자는 객체의 특성을 보여줄만하다고 하는건 클래스의 이름뿐이다.

    하지만 정적 팩터리 메서드는 이름을 가질 수 있다.

    ```java
    BigInteger.probablePrime
    ```
    위의 메서드는 정적메서드인데 값이 소수인 BigInteger를 반환한다.
    이름으로 반환될 객체의 특성을 쉽게 파악할 수 있다.

2. 호출마다 인스턴스생성을 하지않아도된다.

    반환하는 객체에서 미리 인스턴스를 생성해놓고 정적 팩터리 메서드를 구현하면 같은 인스턴스를 계속해서 반환해준다. 즉 클래스를 싱글톤으로 만들 수 있다.

3. 반환 타입의 하위 타입 객체를 반환할 수 있다.

    슈퍼클래스의 서브클래스를 반환 할 수 있게된다. 사용자는 슈퍼클래스로 반환 받은 것 같지만 서브 클래스를 사용 할 수 있게된다.

    이는 인터페이스 기반 프레임워크의 핵심 기술 이다.

    반환타입은 인터페이스 타입으로 하고 실제 반환하는 객체는 구현체를 반환하도록 함으로써 구현내용은 숨길 수가 있다.

    자주 사용하는 Java.util.Collections에는 많은 메서드가 선언돼있지만, 우리는 구현체의 내용을 볼 수 없다.(non-public 이기때문)

        java 9 private method에 대해

        java 8 부터 인터페이스에 default메서드 사용이 가능해지고 public static method 사용이 가능해졌다. default는 해당 인터페이스에 메서드를 구현이 가능하게 해주고, public static method는 객체 생성없이 바로 호출이 가능해졌다.

        java 9 이후 private method 가 추가되었는데 왜 필요한지 알아보았다.
        아래 예시코드를 보자

        
        class Java9{
            public static todoSomething(){
                // 등교한다
                // 수업을 듣는다.
                // 공부를 한다
                // 잔다.
            }
            public static todoSomethingTomorrow(){
                // 등교한다
                // 책을 읽는다.
                // 술마신다.
                // 잔다.
            }
        }
        
        위 메서드에서 등교한다와 잔다는 행위는 중복돼있고 따로 분리한다.
        이 때 분리할 메서드가 과연 밖으로 노출될 필요가 있을까?
        todoSomething()과 todoSomethingTomorrow()에서만 사용하므로 노출될 필요가 전혀 없다.
        그래서 private static으로 외부로부터 접근을 제한해준다.

4. 입력 매개변수에 따라 매번 다른 크래스의 객체를 반환할 수 있다.

    말이 어렵다... 예시를 가지고 이해해보자.

    EnumSet 클래스는 정적 팩터리메서드만을 제공해주는데, 우리가 원소의 개수를 넘겨주면 해당 개수에 알맞은 인스턴스를 반환해준다.

    실제 내부에서는 원소 개수가 64개일때와 그 이상일 때 반환하는 인스턴스가 다르다.

    이처럼 메서드를 호출하는 사용자는 매개변수만 넘겨줄 뿐 반환되는 인스턴스가 어떤 인스턴스인지 알 수도 없고 알 필요도 없다.

    단순하게 내가 반환받을 클래스의 하위타입들이기만 한다면 아무런 문제가 없는것이다.

5. 정적 팩터리 메서드를 작성하는 시점에는 반활할 객체의 클래스가 존재하지 않아도 된다.

    역시 어렵다. 무슨 말인지 이해하는데 한참이 걸렸다.

    책에서 JDBC를 예시로드는데 해당 내용은 프레임워크를 어느정도는 알고 있어야 이해가 쉬울 듯 하다.

    JDBC에서 getConnection이라는 메서드가 있는데 해당 메서드는 인스턴스를 반환하기는 하지만, **중간에 어떤 DB가 연결되느냐에 따라 반환하는 인스턴스가 달라진다**. 처음엔 NoSQL이 연결되어 connection을 얻어왔다고 가정하자.

    이후에 다른 DB에 연결하고 싶어 DBdriver를 MySQL로 교체를 해주면 getConnection은 MySQL에대한 인스턴스를 반환한다.

    핵심은 메서드를 먼저 작성해 놓고 반환될 인스턴스는 나중에 결정할 수 있다는 점이다.

---

**단점**

1. 상속을 위해서는 생성자가 필요하다.
    

2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.
    
    맞는 말이다. 나도 어떤 정적 메서드가 어떤 인스턴스를 반환하는지 그때그때 찾아봐야 알지 자주쓰는 메서드가 아니라면 쉽게 파악하기 어렵다.
    생성자는 API설명에 확실하기때문에 인지하기는 쉽다.

    그래서 정적 팩터리 메서드의 명명방식이 존재한다. (Official은 아님)


**정리**

1,2번은 단순하게 이름을 가질 수 있고, 싱글턴을 보장할 수 있다는 내용이다.
3,4,5번은 좀 더 유연한 프로그래밍을 할 수 있도록 도와준다. 구현내용을 외부에 공개하지않고 인터페이스만으로 개발이 가능하도록 하고, 메서드의 작성시점이 인스턴스 반환시점에 국한되지않게 만들 수 있다.

어렵다. 매우 어렵다. 공부를 열심히 하자.







