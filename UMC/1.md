1주차
===

- Server & Client
    - 서버와 클라이언트의 관계는 무엇인가요?
        
        클라이언트와 서버는 네트워크로 연결되어 정해진 통신규약에따라 요청과 응답을 주고받는 관계다.
        
        웹서버를 예로들면, 클라이언트는 요청을하게되고 웹브라우저가 HTTP메세지를 생성하게된다.
        
        HTTP메세지는 TCP/IP패킷으로 감싸지고 네트워크망으로 전송되어 수많은 서버노드를 거쳐 서버에 전달된다. 서버는 해당 요청을 처리하고 동일하게 HTTP메세지를 생성해 클라이언트에게 응답한다.
        
    - 한번 서버는 영원한 서버일까요?
        
        서버는 언제든 의도치않게 종료될 수 있다. 그래서 서버는 다중화를 통해 한 쪽 서버가 종료되면 다른 서버로 서비스를 제공해야한다. 또한, 사용자가 단기간에 급증할 때 서버를 대량증설하고 해제 할 수도 있다.
        
    - 서버의 역할 및 기능이 무엇일까요?
        
        본질적으로 서버는 클라이언트에게 서비스를 제공해주는 역할을 맡는다. Youtube Server, Naver Server, Google Server 등 많은 서버가 있지만 이들은 공통적으로 요청에대한 처리를 마치고 응답을 주는 점은 같다. 사용자는 다양한 요청을 보낼 수 있다. 회원가입, 게시글 요청, 게시글 저장, 댓글 저장, html파일 요청 등 다양한 요청을 서버는 처리할 수 있다. 
        
- OS(운영체제)
    - 운영체제란 무엇일까요?
        
        컴퓨터의 자원(하드웨어)를 효율적으로 관리하기위한 인터페이스를 제공하는 기반 시스템이다.
        
        운영체제는 가장 밑에 기반이되는 커널위에 셸과 응용프로그램이 올라가게된다.
        
        커널은 드라이버를 이용해 하드웨어를 제어한다. 항상 메모리상에 올리가있으며, OS의 핵심적인 부분으로 하드웨어와 운영체제의 인터페이스를 제공하는 역할을 한다. 응용프로그램이 안정적으로 작동하기위해선 안정적인 커널이 필요하다. 
        
        하나의 예시로 안드로이드 OS는 기반커널이 Linux커널을 사용하므로 Linux계열로 본다.
        
    - 운영체제의 종류에는 무엇이 있나요?
        
        가장 많이 이용되는 Windows가 있고, 그 외에도 MacOS, Linux, Unix 등 존재하며, Unix의 파생 운영체제가 굉장히 많다. MaxOS와 Linux도 Unix계열의 운영체제이고 모바일 운영체제인 iOS도 Unix의 파생 운영체제이다. 안드로이드 운영체제도 Linux운영체제가 기반이므로 Unix의 파생형이라볼 수 있다.
        
    - 운영체제가 필요한 이유는 무엇일까요?
        
        운영체제가 존재하지 않는다면 사용자는 컴퓨터의 하드웨어를 직접 조작하고 관리해야한다. 운영체제가 제공하는 인터페이스없이 하드웨어를 관리한다는것은 너무 복잡하고 어렵기때문이다. 운영체제는 흔히 사용하는 PC, 스마트폰에만 있는 것이 아니라 MP3, 2G폰에도 운영체제가 설치되어있다. 우리가 효율적이고 쉽게 디바이스를 작동시키기위해선 운영체제가 필수적이다.
        
    - 운영체제는 서버인가요?
        
        운영체제는 서버가 아니다. 서버용 OS가 존재할 뿐이지, 운영체제 자체가 서버는 아니다. 서버용 운영체제 위에서 서버를 구동할 수 있다.
        
    - 리눅스를 서버를 위해서 많이 사용하는 이유는 무엇일까요?
        
        첫 번째로 경제적인 측면을 제외할 수 없을 것 같다. Linux는 무료 오픈소스 운영체제로 365일 무료로 제공하고 있어 서버를 구축함에 있어 비용이 들지않는다.
        
        두 번째는 보안성이다. 오픈소스 운영체제로 예로부터 개발자들이 많이 사용해왔었기때문에 그만큼 악의적인 공격을 가장 많이 받아왔다. 당연하게도 많은 공격을 받은 만큼 그에대한 대응또한 있어왔기때문에 보안성을 꾸준히 키워왔다.
        
        세 번째는 구조적 안정성이다. 위에서 말한 이유와 마찬가지로 예로부터 많은 양의 버그를 많은 개발자들이 수정해오면서 점차 안정적인 OS로 발전해왔다. 실제로 Unix계열의 파생형은 셀 수 없이 많고 그만큼 OS소스를 많은 개발자들이 마주하고 개선시키는 작업이 이루어져온것이다. 이에 대비해서 Windows는 오픈 소스가 아니기때문에 내부 소스를 마주할 일이 없기때문에 상대적으로 수정에 보수적이게되었다.
        
- 웹 서버(WS)
    - 웹 서버는 무엇인가요?
        
        서버의 한 종류로 HTTP를 이용해 웹브라우저와 통신한다. 하드웨어 측면에서 웹서버는 컴포넌트파일(html, 이미지파일, css, javascript)을 저장한다. 웹서버는 주로 SSL을 이용해 데이터를 암호화하고 TLS를 이용해 데이터의 무결성을 보장한다.
        
        웹서버에는 정적웹서버와 동적웹서버가 있는데, 정적웹서버는 HTTP서버가있는 컴퓨터로 구성되어 있다. 브라우저가 요청을 보내고 올바른 요청이 웹서버에 도달하면 HTTP서버가 요청에대한 응답을 내려준다.
        
        동적 웹서버는 정적웹서버에 추가적인 소프트웨어(WAS)로 구성되어있다. 예를 들어 html파일을 요청했을때 정적웹서버는 요청한 html파일만 응답해주지만 동적웹서버는 기본적인 html틀안에 데이터를 추가해서 응답해준다.
        
    - 웹 서버의 예시로는 무엇이 있나요?
        
        Apache, Nginx, IIS 가 대표적인 웹서버이고, hostadvice조사에 따르면 각각 40%,30%,10%의 점유율을 갖고있다.
        
    - 웹 서버가 왜 필요한가요?
        
        대부분의 웹페이지들은 동적웹페이지를 말한다. html파일에 추가적인 데이터를 DB에서 얻어와 웹브라우저가 랜더링을 마친후에 응답해준다. 하지만 이미지파일과같은 정적데이터들은 html요청 시에 함께 응답해주지않고, html을 먼저 응답받은 뒤 알맞은 추가적인 요청을 다시 웹서버에게 보내야하는데 정적인파일은 웹 서버가 빠르게 응답하게되므로 성능이 향상된다.
        
- 웹 어플리케이션 (WAS)
    - 웹 어플리케이션은 무엇인가요?
        
        웹 컨테이너, 웹 서블릿으로도 불리는 WAS는 DB조회 혹은 비즈니스로직을 처리하는 동적페이지를 만드는 역할을 한다. 위에 언급한 웹서버와의 구조적 분리를 위해서 만들어졌고, 웹서버는 정적페이지, WAS는 동적페이지를 제공하는 역할을 한다.
        
    - 웹 어플리케이션의 예시로는 무엇이 있나요?
        
        Tomcat, JBoss, Jeus, Web Shpere 등이 있다.
        
    - 웹 어플리케이션이 왜 필요한가요?
        
        정적페이지는 정적인데이터만 응답해주면 되지만, 사용자의 요청에의한 동적인 웹페이지는 WAS가 담당하도록 구조적으로 분리했다. 동적페이지는 내부에서 DB와 연결되어 요청한 데이터를 특정 로직에의해 처리하고 알맞은 데이터를 응답한다.
        
    - WAS와 WS를 같이 사용하는 이유는 무엇인가요?
        
        클라이언트의 요청에 서버는 한 번에 모든 파일을 내려주지않는다. 예를들어 Naver에 접속한다하면, html파일은 먼저 받게되고 필요한 이미지파일등은 후에 다시 요청을 보내 다시 응답받아야한다. 이 때 정적인데이터는 WAS를 거치지않고 WS에서 빠르게 처리해주고 동적인 영역은 WS가 WAS에 요청을보내고 WAS가 WS에 응답후 클라이언트에게 응답한다. 즉 구조적으로 동적인 영역과 정적인영의 구분을 위해 두 가지를 함께 사용한다. 만약 WAS가 없다면, 사용자의 요청이 들어올 페이지를 미리 모두 만들어놓고 기다려야하지만 그렇게되면 자원의 낭비가 심해질 것이다.
        
- MSA
    - MSA는 무엇의 약자인가요?
        
        Micro Service Arcitechture
        
    - MSA는 무엇인가요?
        
        기존의 아키텍쳐는(아직도 많이 사용된다) Monolithic Architecture로 모든 소프트웨어 구성요소가 하나의 서버 통합된 형태였다. MA는 하나의 장애가 서버전체로 퍼질 수 있는 단점이 있고, 서비스가 커질 수록 전체 구조를 파악하기가 어려워진다. 하지만 서버를 작은 단위로 잘게 나눠 여러개의 서버로 운영하게되면 구조파악도 용이하고 하나의 장애는 그 서버에만 영향을 미치게된다. 그리고 독립적인 배포가 가능해지고 장애가 발생해도 서버 전체를 내릴 필요없이 해당 서버만 대응해주면된다.
        
    - MSA는 왜 사용할까요? 어떤 상황에서 사용할까요?
        
        장애의 관점에서 기존의 MA방식은 장애의 영향이 서버전체에 퍼질 우려가 있지만, MSA로 서버간의 의존도를 낮게 설계하면 그만큼 전체 서버에 영향을 미치지않게 할 수 있다.
        
        특정서버에대한 확장성이 늘어나게된다.
        
        배포를 독립적으로 할 수 있기때문에 서버의 중단없이 배포 할 수 있다. 중단없는 배포의 장점은 요구사항을 빠르게 수정하고 다시 배포하기 용이하다는 점이다.
        
- 도커
    - 도커는 무엇인가요?
        
        우선 컨테이너라는 개념부터 설명하자면, 서로 다른 앱이 각각의 실행환경까지 감싸서 서로 간섭이 없이 구동되는 격리 기술이다. 예시를 들자면, 롤과 피파가 하나의 컴퓨터에서 구동하지만, 서로 CPU나 메모리를 공유하지않고 완전하게 격리된 환경에서 구동되게하는 기술이다.
        
        이 컨테이너를 다루는 도구를 컨테이너 런타임이라하고 컨테이너 런타임중 가장 유명한 것이 ‘도커’라는 것이다.
        
    - 도커를 왜 사용하나요?
        
        팀워크를 할 때 언어와 프레임워크의 버전이 달라 충돌하는 경우가 생길 수 있다. 이 때 도커 이미지에 버전을 미리 정해놓고 이미지를 컨테이너화시키면 로컬의 간섭없이 독립적으로 구동이 가능하다.
        
        또 다른 장점은 내가 제공하는 서버를 다른 서버로 옮겨야 할 때, 내가 쓰던 언어와 프레임워크의 도커 이미지를 가져와 새로운 서버에 컨테이너를 만들면 충돌없이 구동할 수 있다. 또한 하나의 서버에 여러가지 서비스를 배포할 수 있는 장점도 있다.
        
        그리고 가상화 방식은 기존 OS위에 가상 OS를 설치하고 그 위에 서버를 올리게되는데 올라가는 서버가 많아질 수록 OS도 그만큼 많아지기때문에 무겁고 느리다. 하지만 컨테이너를 기반으로 배포하게되면 하나의 OS에서 구동되지만 격리시스템은 그대로 유지되기때문에 상대적으로 가볍게 구동이가능하다.
        
        (PS 컨테이너는 OS의 커널을 공유한다)
        
- 쿠버네티스
    - 쿠버네티스는 무엇인가요?
        
        위에서 설명한 컨테이너 런타임(대표적으로 도커)를 통해 컨테이너를 다루는 도구이다. 여러 서버에 컨테이너를 분산 배치하고 교체하며 컨테이너의 환경설정을 도와준다. 이러한 일을 컨테이너 오케스트레이션이라고 한다. 즉 쿠버네티스는 컨테이너 런타임(도커)를 이용해 컨테이너 오케스트레이션을 수행하는 도구이다.
        
    - 쿠버네티스를 왜 사용하나요?
        
        위에서 도커를 이용해 컨테이너를 다룬다고했다. 그렇다면 도커가 10개… 20개…  100개로 늘어난다면 관리하기가 쉽지않을것이다. 이럴때 쿠버네티스를 사용해 컨테이너 오케스트레이션을 수행한다. 다수의 컨테이너를 관리 조율하는 시스템이다. 
        
        쿠버네티스는 컨테이너를 모니터링하여 컨테이너중 하나라도 죽으면 재빨리 재시작한다.
        
        즉, 한개의 컨테이너만 사용할 것이라면 쿠버네티스는 필요없지만 다수의 컨테이너를 사용하고 관리해야한다면 쿠버네티스를 사용해야만한다.
        
- 프로토콜
    - 프로토콜이 무엇인가요?
        
        서로 다른 컴퓨터가 자원을 주고받을때 통신방식에대한 약속을 하는것을 말한다.
        
        http프로토콜 TCP/IP프로토콜 이 예시이다.
        
    - 네트워크란 무엇인가요?
        
        우리는 가정에서 여러 컴퓨터로 하나의 프린터기를 사용한다. 네트워크망이 있기때문에 각각의 컴퓨터와 프린터기가 연결되어 사용할 수 있다.
        
        또 우리는 여러사람들이 모여 하나의 응용프로그램에서 대화를 나누고 게임을하기도한다. 이 또한 네트워크가 있기때문에 서로서로 연결될 수 있는 것이다.
        
        통신을 위해 ip라는 각 컴퓨터들의 고유주소를 부여하고 네트워크 내의 수많은 노드(네트워크의 연결지점)를 통해 수많은 컴퓨터들과 소통할 수 있게된다. 또한 포트번호를 통해 하나의 컴퓨터로 들어오는 여러가지 패킷에대한 요청과 응답을 정해진 프로토콜을 이용해 원활하게 처리한다.
        
    - OSI Model, TCP/IP 모델은 무엇인가요?
        
        OSI 7계층
        
        1. 물리적 계층 : 데이터를 단순히 0과1의 비트로 전송을 담당하는 계층으로 특정한 알고리즘이나 오류제어기능은 없다.
        
         2. 데이터링크 계층 : MAC주소를 통해 통신하며 서로 연결된 장치끼리 신뢰성있는 정보전송을 담당한다. 오류검증이나 재전송기능이 있다.
        
        1. 네트워크 계층 : 네트워크에는 여러개의 노드가 있고 이 노드들의 경로를 찾아주는 역할을 한다. 가장 중요한 기능은 데이터를 목적지까지 안전하고 빠르게 이동하게하는 라우팅 기능이다.
        2. 전송 계층 : TCP 프로토콜을 사용하며, 포트를 열어 응용프로그램들이 전송 할 수있게해준다.
        3. 세션 계층 : 통신을 관리하는 방법을 제공하는 계층으로 연결이 끊어지거나 연결이 장기간 지속된다면 연결을 끊었다가 재연결하는 과정을 수행한다.
        4. 표현 계층 : 응용프로그램이 생성한 데이터를 네트워크형식에 맞게 변환하는 계층이다. 인코딩된 문서를 ASCII로 변환하고, 해당 데이터가 text인지 img인지 구분한다.
        5. 응용프로그램계층 : 웹브라우저가 의존하고 사용자와 상호작용하는 유일한 계층으로 모든 형식의 데이터를 전달받는다.
        
        TCP/IP 4계층
        
        1. 애플리케이션 레이어 : OSI계층의 5,6,7에 해당한다. 클라이언트가 http프로토콜을 이용해 데이터를 요청하고 표현계층으로 이동하여 데이터를 암호화하거나 응답이 들어올땐 바이너리 데이터를 우리가 볼 수있는 형식으로 변환한다. 세션계층은 데이터의 무결성 신뢰성을 보장한다.
        2. 전송 레이어 : TCP프로토콜을 이용해 세션으로부터 받은 데이터를 잘게 쪼개 일련번호를 부여한다. UDP도 이 레이어에서 사용하지만 일련번호를 사용하지않는다. 하지만 그만큼 덧붙는 데이터가 작기때문에 속도바 빠르다.
        3. 인터넷 레이어 : IP를 이용해 라우터를 돌아다니며 목적지로 전달한다
        4. 네트워크 인터페이스 레이어 : 데이터링크 계층과 물리 계층이 해당 레이어에 속하며 실제 물리적인 장비와 연관되어있다.
    - 하나의 통신을 위해서 거치는 프로세스는 어떻게 되나요?
        
        사용자가 네이버에 접근한다고 가정하자. 사용자는 주소창에 주소를 입력하면 웹브라우저는 DNS서버에서 요청한 주소의 IP를 반환하고 전송계층으로 데이터(HTTP요청 메세지)를 전달한다. 전송계층에서 TCP를 이용해 요청메세지를 잘게 쪼개 번호를 부여하고 인터넷 계층으로 전달한다. 인터넷계층에서 IP를 이용해 라우터를 돌아다니며 데이터를 전달한다. 이 과정들을 캡슐화라고 하며 상위 계층에서 하위 계층으로 데이터를 전송할때 각자의 헤더를 추가해 데이터를 전송한다. 이 헤더는 계층에 따라 IP주소 포트번호 등 데이터가 목적지에 도착해서 역으로 캡슐화가 진행될때 계층에대한 정보를 제공해준다.
        
- IP
    - 외부 IP와 내부 IP의 차이가 무엇인가요?
        
        외부 IP는 공인 IP라고도 부르며 인터넷 서비스 공급자가 제공하는 IP다. 예를들면 한 가정에서 SKT망을 사용한다면 SKT는 가정에 하나의 인터넷선을 제공하는데 이 인터넷선이 공인 IP를 부여한다. 공인 IP는 내/외부 접근이 가능하다.
        
        내부 IP는 사설 IP라고 부르며 주로 가정에서 사용한다. 위 예시를 다시 들자면 SKT에서 제공한 선을 라우터(공유기)에 연결하고 한 가정에서 라우터를 이용해 여러 기기들을 유/무선으로 연결하는데 이 때 부여되는 IP가 사설 IP이다. 
        
        공인 IP는 전세계에서 유일하며, 사설 IP는 라우터 내에서 유일하다. 사설은 외부로부터의 접근이 불가능하지만 공인은 내외부 접근이 가능하다. 공급주체도 공인은 인터넷망 회사지만 사설은 라우터가 제공한다.
        
    - 공인 IP와 사설 IP에 대해서 알아봅시다.
        
        공인 IP와 사설 IP는 외부 IP와 내부 IP와 같은 말이다. 
        
    - NAT는 무엇일까요?
        
        NAT는 네트워크주소변환기술로 라우터안에 내장되어 여러개의 사설아이피가 하나의 공인아이피를 이용해 인터넷에 접속하기위한 기술이다. 
        
        공인 아이피는 한정되어있으므로 하나의 공인 아이피를 여러개의 사설아이피를 사용해 통신할 수 있게 해준다. 이 때 사설아이피가 공인아이피를 통해 통신하기위해선 네트워크 주소가 변환되어야하는데 이 일을 NAT가 라우터 내부에서 처리해준다.
        
- 도메인
    - DNS는 무엇인가요?
        
        네이버 접속 예시를 들어 설명하자면, 클라이언트는 주소창에 [naver.com](http://naver.com) 을 입력하면 짧은 순간에 브라우저는 DNS라는 서버에 ‘나 여기 들어가고싶어’ 라는 메세지를 보낸다. 그 메세지는 ‘naver.com의 IP주소를 알려줘’라는 의미이다. DNS는 naver.com이 어떤 IP주소를 갖는지 찾아서 웹브라우저에게 전송하고 웹브라우저는 해당 IP를 받아서 접속한다.
        
        즉 DNS는 도메인 주소(naver.con)와 IP주소를 연결해놓은 서버이다.
        
    - 도메인 동작원리에 대해서 알아봅시다.
        
        위 예시에서 설명했듯이 IP를 요청하고 응답하는 과정은 당연하게도 데이터베이스에 접근해 데이터를 얻어오는 방식이다.
        
        즉 분산데이터베이스구조를 가진다. 상위 기관은 하위기관이 요청한 도메인을 생성하고 IP를 변경해준다.
        
        DNS서버는 권한이 있는 서버인 네임서버 권한이 없는 서버인 리졸버로 구성되어있고, 리졸버는 클라이언트의 요청을 네임서버에 전달하고 네임서버가 찾은 데이터를 리졸버가 클라이언트에게 다시 전송한다.
        
        DNS는 생각보다 거대하다. 생각해보면 세상엔 수 많은 도메인 주소가 있고 일대일대응으로 IP주소 또한 수 없이 많다. 이런 방대한 양을 관리하고 응답해주기 위해서 분산식처리를 이용한다. 도메인 주소를보면 .com으로 끝난다던지 .kr로 끝난다던지 다양한 구분자들이 있는데 이 구분자들로 클라이언트이 요청이 알맞은 네임서버에 도달하게끔 유도한다.
        
    - 서브도메인은 무엇인가요?
        
        서버가 갑작스러운 사용자의 증가로 증설해야할 때 도메인을 여러가지로 나누워 분산하여 처리해야한다. [naver.com](http://naver.com) / [blog.naver.com](http://blog.naver.com) / [cafe.naver.com](http://cafe.naver.com) 이 서브도메인의 예시다.
        
- 포트
    - 주로 사용하는 포트번호에 대해서 알아봅시다.
        
        http는 80포트 https는 443포트를 주로 사용한다.
        
    - 포트포워딩이란?
        
        포트포워딩이란 단어 그대로 포트를 전달해주는 것을 의미한다. 누구에게 어떤 포트를 전달하는지 알아보자.
        
        위에서 설명했듯이 일반 가정용 컴퓨터의ip는 사설ip다. 사설 ip는 라우터(공유기)에 연결되어 라우터가 할당한 ip를 사용한다고 했다. 라우터에는 인터넷서비스제공자의 공인ip를 통해 연결되어있다.
        
        또한 WAT를 이용해 외부와 내부의 네트워크 주소전환기술을 사용한다고도 했다.
        
        포트포워딩이란 WAT의 기술이다.
        
        위키피디아 참고
        
        In[computernetworking](https://en.m.wikipedia.org/wiki/Computer_networking),**portforwarding** or?**port mapping**?is an application of?[network address translation](https://en.m.wikipedia.org/wiki/Network_address_translation) (NAT) that redirects a communication request from one?[address](https://en.m.wikipedia.org/wiki/IP_address) and?[port number](https://en.m.wikipedia.org/wiki/Port_number) combination to another while the?[packets](https://en.m.wikipedia.org/wiki/Network_packet)?are traversing a network gateway, such as a?[router](https://en.m.wikipedia.org/wiki/Router_(computing)) or?[firewall](https://en.m.wikipedia.org/wiki/Firewall_(computing)).
        
        라우터외부에서 내부로 내 컴퓨터에 접속하기 위해선 내 컴퓨터의 IP외에도 내 컴퓨터의 port정보가 필요하다.
        
        예시를 들어 설명해보고자한다.
        
        내가 컴퓨터에 서버를 설치했고, 사용자들이 내 서버에 들어오길 기대하고있다. 난 어떤 정보를 사용자들에게 제공해야할까? 내 컴퓨터의 IP? 라우터(공유기)의 공인 IP? 정답은 라우터의 공인 IP다. 사설아이피를 알려준다는건 “202동 901호로 와” 라는 말과 같다. 세상엔 수 많은 202동 901호가 있다… 공인IP를 알려준다는건 상세한 주소를 알려준다.(전세계 하나뿐이기때문). 그런데 이때 상세주소를 알려줘도 라우터에 접근하면 라우터에 물려있는 기기가 다수 존재하므로 특정 포트를 지정해줘야한다. “사용자가 공인IP의 8000포트로 들어오면 내컴퓨터IP의80포트로 들어오게해줘” 이 한 문장이 포트포워딩 설정을 의미한다.

- TCP vs UDP
    
    TCP패킷에는 전송제어, 포트번호, 순서정보 등등 안정적인 전송을 위해 많은 정보들이 함께 들어있다. 하지만 UDP는 포트정보와 체크섬정보외에는 TCP만큼의 정보가 없기때문에 그만큼 가볍다.
    
    요즘은 TCP가 대부분을 차지하지만 점차 가벼운 UDP가 각광받고 있으며, 실제 Google에 검색페이지 소스보기를 해보면 UDP를 사용한 HTTP3를 볼 수 있다.
    
- Proxy
    
    프록시에는 포워드 프록시, 리버스 프록시 두 종류가 있다.
    
    클라이언트와 Web서버 중간에서 매개체 역할을하는 서버로 클라이언트에서 웹서버 방향은 포워드 프록시 웹서버에서 클라이언트방향은 리버스 프록시라고 부른다.
    
    포워드 프록시서버의 경우 클라이언트가 도메인주소를 입력하면 프록시서버가 이를 받아서 웹서버에게 전달하고 웹서버의 응답을 프록시서버가 받아서 클라이언트에게 내려준다.
    
    프록시서버의 장점은 클라이언트가 이전에 접속한 액세스기록을 캐싱하여(저장하여) 남겨두기때문에 예전과 동일한 요청이 들어올 경우 Web서버를 거치지않고 앞단에서 빠르게 응답해준다.
    
    리버스 프록시는 웹서버쪽에 위치하여 클라이언트의 요청을 최초로 받아서 요청을 분산해서 웹서버에게 분배해준다. 동적인 처리와 정적인 처리를 구분해서 웹서버에게 요청을 분산해주기때문에 웹서버의 부담이 줄어든다. 포워드 프록시와 마찬가지로 동일한 데이터는 캐싱하고있다가 캐싱된 내용을 돌려준다.
    
- 이더넷
    
    이더넷과 인터넷 한글로도 발음이 비슷하지만 영문은 더 비슷하다. Ethernet, Internet. 
    
    이더넷은 인터넷을 활용할 때 사용하는 하나의 기술 규격이다. 같은 네트워크안에서 컴퓨터끼리 정보를 주고받을 때 사용한다.
    
    컴퓨터 네트워크 구성초기에는 컴퓨터와 컴퓨터를 하나의 선으로 연결해서 사용했다. 그런데 컴퓨터가 한 대 더 추가되면 선이 2개 더 필요해지고 한 대가 더 추가되면 그만큼 선의 갯수는 기하급수적으로 늘어난다. 이 때 허브라는 개념이 생겨났다. 각 각의 컴퓨터는 허브에 연결되어 A에서 B로 데이터를 전송하기위해선 A에서 허브를 거친 뒤 B에게 데이터가 전송되는 형식이다. 이를 이더넷 허브라고 부른다. 그런데 허브는 A에서 B에게만 데이터 전송을 기대했지만, 허브는 연결된 다른 허브에도 데이터를 전송해 더미 허브라고 불린다.
    
    그래서 등장한 것이 이더넷 스위치다. 이더넷 스위치에는 컴퓨터의 고유주소인 MAC주소를 기억하고 있어서 원하는 MAC주소에만 데이터를 전송할 수 있게해준다.
    
    위에서 언급했지만 이더넷은 “같은 네트워크”에서의 전송을 담당한다. 즉 A라는 PC방이 하나의 네트워크로 구성되어있을 때 미국에있는 B라는 PC방과는 소통이 불가능하다.
    
    이렇게 더 넓은 통신을 위해 등장한것이 인터넷이고 이더넷 스위치를 라우터(공유기)에 연결하여 다른 네트워크와도 통신할 수 있게된다.
    
    정리하면 이더넷은 LAN(근거리통신망)을 활용할 때 사용하는 기술규격이고 라우터는 LAN을 WAN(근거리통신망)으로 확장 시켜주는 역할을 한다.
    
- MAC 주소
    
    이번주에 알아본 IP주소도 컴퓨터 고유의 주소이고 MAC주소도 컴퓨터 고유의 주소다.
    
    이 둘은 무슨 차이가 있을까?
    
    이더넷에서 살펴봤지만 MAC주소는 “같은 네트워크”에서 서로 통신할 때 서로를 알아보기위해 사용한다.
    
    ip는 다른 네트워크와 통신할 때 사용한다.
    
    그럼 ip로 통신할 때는 MAC주소를 사용하지않을까? 답은 아니다.
    
    같은 네트워크에서 통신할 땐 서로 MAC주소를 공유해 통신한다했다. 다른 네트워크와 통신할때도 마찬가지다. 통신하고싶은 컴퓨터의 MAC주소를 같은 네트워크상에 있는 모든 컴퓨터에게 요청한다. 그런데 같은 네트워크에 없는 컴퓨터라면 라우터가 대신 외부 네트워크에있는 해당 컴퓨터의 MAC주소를 찾아준다. 이렇게 라우터를 통해 MAC주소를 통해 접근이 가능해진다. 즉 원거리 통신에서는 IP와 MAC주소를 둘 다 사용하는것이다.
    
- 서브넷 마스크
    
    먼저 IP에대해 자세하게 알아보자.
    
    IPv4는 [XXX.XXX.XXX.XXX](http://XXX.XXX.XXX.XXX) 처럼 XXX 라는 하나의 옥텟이 4개가 붙어있는 형식이다.
    
    하나의 옥텟은 8bit를 표현 할 수 있고, 약 42억개의 주소를 표현한다.
    
    얼핏보면 IP가 무작위적인 숫자로 이루어진것 같지만, 각자의 역할이 나뉘어져있다.
    
    첫 번째 옥텟이 0XXX로 시작하면 A클래스 10XX는 B클래스 110X는 C클래스 1110은 D클래스 1111은 E클래스로 구분한다.
    
    A클래스는 대규모 네트워크 환경에서 사용되고 첫번째 옥텟은 네트워크ID이고 나머지 옥텟은 호스트ID로 사용한다. 호스트ID를 24비트로 할당할 수 있기때문에 대규모 IP를 할당할 수 있다.
    
    C클래스는 3개의 옥텟을 네트워크ID로 1개의 옥텟을 호스트ID로 사용하기때문에 소규모 네트워크에서 사용한다.
    
    서브넷 마스크는 이렇게 네트워크ID와 호스트ID를 분리하는 역할을 한다.
    
- 소켓 프로토콜
    
    소켓은 클라이언트와 서버가 통신할 때 필수적인 요소다.
    
    내가 서버에게 어떤 요청을 보낼때 서버의 IP와 포트가 필요하다. 
    
    서버 또한 클라이언트와 소통하기위해 소켓을 열어놓고 대기하고있다.
    
    소켓은 양방향 통신을 위해 IP와포트정보를 이용해 TCP프로토콜로 통신을 시작한다.
    
- 패킷에 IP와 Port가 들어가야하는 이유
    
    택배기사님을 예시로 들자면 매우 쉽다. 쿠X에서 맥북을 구매하는데 아무런 주소도 적어놓지 않고 주문을하면 택배기사님은 어디에 배송을 해야할지 전혀 모를것이다.
    
    그런데 주소를 적을 때 서울시 XX구 XX동 XX아파트(IP) 라고만 적고 동과 호수는 적어놓지 않았다면 이것또한 문제다. XX아파트엔 많은 동과 호수가 많을텐데 어떻게 배송이 잘 될 수 있을까.
    
    그래서 Port번호가 필요하다. 동과 호수로 비교하면 쉽다. XX동 XX호까지 추가하면 배송은 안전하게 도착할 것이다.
    
- SSH의 원리
    
    서버 인증
    
    서버는 공개키와 개인키(비밀키)를 생성한다. 클라이언트가 접속을 시도하면 서버는 공개키를 보내주고 클라이언트는 난수를 생성해 해시값을 만들고 해시값을 서버의 공개키로 암호화하여 서버에 전송한다. 서버는 암호화된 해시값을 자신의 개인키로 복호화하여 난수값을 만들어내고 난수값을 다시 해시값으로 만들어 클라이언트에게 전송한다. 클라이언트는 자신이 생성한 해시값과 전달받은 해시값을 비교해 서버를 안전한지 판단한다.
    
    사용자 인증은 위 과정을 클라이언트와 서버가 역으로 바꿔서 수행한다.
    
- SSH와 SFTP의 Port번호(22)는 왜 같은가?
    
    SFTP는 SSH의 파일전송 버전이라 생각하면된다.
    
    SSH의 기본 포트는 22번인데 SFTP도 22번을 사용하지만 SFTP의 포트번호를 변경해서 사용 할 수있다.
    
- 서버 보안을 위해서 어떤 부분을 신경써야할까?
    
    OS의 근본적인 취약점도 신경써야하고 애플리케이션을 통해 들오는 공격도 신경을 써야한다.
    
    XSS(URL에 코드를 직접삽입하여 서버에 직접 전송해 서버를 망가트리는 공격)나 SQL인젝션등 여러 공격에 대비해야한다.
    
    또한 로그기록을 남겨 악의적 공격이나 특이한 행동을 모니터링해야한다.
    
    자바코드를 쓰면서 sout를 많이 이용하지만 현업에서는 콘솔로 로그를 남긴다고한다.
    
- NAVER 서버는 서버가 한 대 이상일 것임. 
서버가 여러대일 경우, 서버간의 통신이 어떻게 이루어질까?
    
    일단 서버끼리 통신하는데 굳이 HTTP를 사용할까 라는 의문이 있었고, 내 예상은 TCP를 이용해 통신 할 줄 알았지만 서버끼리의 통신에서 HTTP를 사용해 통신한다고한다.