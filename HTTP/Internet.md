인터넷 네트워크
==
내가 친구와 컴퓨터를 이용한 통신은 거대한 인터넷 네트워크 아래에서 이루어진다.

> 나의 컴퓨터 - 네트워크(인터넷) - 친구

내가 안녕이라는 데이터를 친구에게 보낸다고 가정하면, 데이터는 매우 복잡한 인터넷에 던져지고 수많은 **노드서버**를 거쳐서 친구에게 도달한다.

실생활에서 집주소없이는 택배를 보낼 수 없는것처럼 컴퓨터도 고유주소를 갖지않고서는 통신이 불가능하다. 그래서 등장한것이 IP(Internet Protocal)이다.

IP
==
> IP : 네트워크상에서 통신을 위한 각 노드의 위치주소  
    4개의 필드로 구성된 숫자로 표현된다. ex)100.100.100.1
    


이제 우리는 주소를 부여받았으니 데이터를 포장해서 주소를 적고 보내기만하면 된다. 하지만 아무 문제없이 데이터가 잘 전송될것만 같지만 실상 그렇지 못하다.

다음은 IP의 한계점들이다.

1. 비연결성

내가 친구에게 데이터를 전송할 때 친구 컴퓨터의 상태에 무관하게 IP프로토콜은 패킷(데이터)를 전송하게된다.
    
    IP패킷이란 도착지 IP와 출발지IP를 적어놓은 부가정보를 뜻하고 이 패킷을 데이터 위에 감싸게된다.

2. 비신뢰성

데이터를 전송하면 중간에 수많은 노드서버를 거친다고 했다. 이때 중간서버들의 상태가 고르지못하여 패킷이 유실되거나, 도착지까지 안전하게 갔다고 하더라도 패킷을 여러개 보냈을 경우 패킷의 순서가 꼬일 가능성이있다.

3. 프로그램의 구분

우리는 하나의 컴퓨터로 여러가지 작업을한다. 음악도 듣고 게임도 하고 웹서핑도하는데, 나의 IP는 하나인데 통신을 주고받는 상대 서버는 여러가지이다. 이 때 각각의 서버들을 구분할 방법이 없다.

위와 같은 **문제점**으로 **TCP프로토콜**이 탄생하였다.


TCP/UDP
==
**TCP**는 IP가 갖는 문제점들을 확실하게 해결해낸다.

IP는 패킷에 도착지와 출발지의 주소를 적어보내지만 TCP는 추가적으로 **도착지와 출발지 PORT, 전송제어, 순서제어** 등 추가적인 정보와 함께 패킷을 보낸다.

위 추가정보로 어떻게 IP패킷이 갖는 문제점을 해결하는지 알아보자.

1. 3 way handshake

3 way handshake란 나와 친구사이에 3번의 요청과 확인이 오고간다.

1.SYN(나:우리 연결할까?) 2.SYN+ACK(친구:OK,우리연결하자) 3.ACK(나:그래 연결하자) 

SYN는 Syncronize(동기화)의 약자이고 ACK는 Acknowloge(승인)의 약자이다.

중요한 점은 **가상연결**이란 점이다. 서로 논리적 연결만 한 상태이지 실제 연결을 한 상태는 아니다. 이렇게 나와 친구가 통신이 가능하다는 것을 서로 확인한 셈이다.

2. 데이터 전달 보증

데이터가 중간서버에의해 유실되더라도 TCP는 서로 데이터를 잘 받았는지 확인이 가능해진다.

3. 순서 보장

IP패킷을 이용하면 중간에 거치는 노드서버들의 경로가 제각각이기때문에 패킷의 순서를 보장할 수 없었지만 TCP패킷은 순서가 틀어졌을 경우에 틀어진 패킷부터 다시보내라는 요청을 보내게되므로 순서가 보장된다.

4. PORT

포트는 하나의 IP에 여러 PORT를 가지고 있다. 아파트를 예시로하면 하나의 동은 IP가 되고 하나의 호가 PORT가 된다고 볼 수 있다.

이렇게 포트를 갖게되면 하나의 IP에서 여러 작업이 가능해진다. 지정된 포트로 패킷이 오고가기때문에 다른 패킷과 충돌할 일이 없어진다.

TCP패킷은 IP패킷과함께 사용되고 **프로토콜 4계층**에의해서 전송된다. 프로토콜 4계층은 차후에 알아보도록하고 UDP에대해 먼저 알아보자.

---
TCP/IP 패킷은 현재 가장 많이 사용되는 프로토콜이지만, 요즘 UDP가 점점 각광을 받고있다.

TCP는 여러가지 정보를 담고있기때문에 용량도 크고 속도도 느리다는 단점이있지만, UDP는 IP프로토콜과 거의 같지만 PORT가 추가된 프로토콜이다.

그렇기때문에 UDP는 TCP보다 속도가 빠르기때문에 점점 사용되는 추세이다.

---

프로토콜 4계층이란 OSI7계층을 TCP/IP에 맞춰 단순화시킨 간단한 구조다.

    어플리케이션 계층 - 전송 계층 - 인터넷 계층 - 네트워크 액세스 계층

좌에서 우방향으로 깊어지는 방식이다.

1. 어플리케이션 계층

크롬브라우저를 예시로든다면 가장 표면에서 사용자와 소통을 담당하는 구간이다. 우리가 브라우저에게 요청을 보내면 브라우저는 사용자의 요청을 HTTP헤더로 감싸서 전송계층으로 넘긴다.

어플리케이션의 프로토콜 : HTTP, HTTPS(보안강화), SSH, DNS 등

2. 전송 계층

통신간에 데이터전송을 보장하는 계층으로 이 곳에서 데이터를 TCP패킷으로 감싼다.

포트번호를 패킷에 추가하게되므로 하나의 IP에 여러 서버와 동시에 충돌없이 통신이 가능해진다.

이후에 인터넷계층으로 패킷을 내려보낸다.

3. 인터넷 계층

이 계층이 TCP패킷을 IP패킷으로 감싸주는 계층이다. 이렇게 TCP/IP패킷이 생성되고 
마지막에 네트워크 액세스 계층으로 내려가 데이터를 전송한다.

DNS
==
Google.com Naver.com 등 모든 도메인은 IP주소를 가지고있고 이 IP주소를 체계적으로 관리할 필요성이 생겼다.

중간에 도메인의 IP가 바뀌더라도 DNS에 내 IP주소는 바뀌었어라고 알려주기만하면 사용자는 IP의 변경에 유연하게 접근이 가능하다.

간단히 말해서 IP주소들을 한 곳에 모아 서버를 만들어놓고 요청이 들어올때마다 서버에서 해당 도메인에대한 IP를 응답해준다.

URL? URI? URN?
==

URI나 URL은 쉽게 접해본 단어들이고, URN은 익숙하지 않은 단어였다.

우선 이들의 포함관계를 살펴보면, **URI**라는 큰 틀안에 **URL** **URN**이 포함되는 구조다.

URI(Uniform Resource Identifier)은 리소스를 다른 리소스와 식별하는 통일된 방식을 말한다.

URL은 URI와 동치라 봐도 무방하고, URN은 리소스자체의 이름을 나타낸다.


    URI(URL)
    구조 : scheme://[userinfo@]host[:port][/path][?query][#fragment]
    예시 : https://www.google.com/search?q=hello&hl=ko


1. **scheme:://** 는 프로토콜(통신규약)을 적는다. http나 https를 사용한다.
https는 주로 많이사용하는 프로토콜로 http의 보안성을 강화한 버전이다. SSL이라는 기술을 사용해 **데이터를 암호화해** 도난시에 데이터를 안전하게 보호할 수 있고, TLS라는 기술을 사용해 **데이터의 무결성**을 보장한다.
데이터의 무결성이란 데이터가 수정되거나 손상을 방지한다.

2. [userinfo@]는 사용자정보를 인증하는 곳으로 거의 사용하지않는다.

3. host 는 말 그대로 서비스를 제공하는 주체이다. 예시에 google.com이 host가 되고, 주소대신 IP를 직접입력할 수 있다.

4. [:port]란 접속포트를 말하는데 http는 80포트 https는 443포트를 이용하며 대부분 생략한다.

5. [/path]란 접속 경로를 말하는데 위의 예시에선 /search라는 경로로 들어가 검색을 진행한다. 주로 계층적구조를 가진다.

6. [?query]는 가장 중요한 부분이다. query parameter, query string 이라고도 부르고,
?표로 시작해 q=hello&hl=ko 처럼 key=value형식으로 되어있고, &로 연결하며 사용한다. **웹서버에 데이터를 넘겨줄때 사용한다**

웹 브라우저 요청 흐름
==
내가 정말 궁금했던 내용이다. 내가 게시글을 조회하거나 게시글을 올리거나 검색을 할 때 브라우저부터 서버까지 어떤 방식으로 데이터가 전달되는지 궁금했다.

    예시 : https://www.google.com/search?q=hello&hl=ko

다음은 구글에 hello라고 검색한 결과의 URI다.

위에 설명했듯이 https 프로토콜로 통신하며 www.gogle.com을 dns서버에서 조회한 후 해당 IP로 접근한다.

계층적 구조로 설계된 path로 /search 경로에 쿼리파라미터(q=hello&hl=ko)를 서버에 넘겨주게 된다.

------
우선 내가 구글에 검색버튼을 누르게되면 내 눈에 검색결과가 보이기까지 그 짧은 순간에대한 과정을 정리해보려한다.

검색버튼을 누르는 순간 웹브라우저는 HTTP 요청메세지를 생성하게된다.

    GET /search?q=hello&hl=ko 
    HTTP/1.1 Host: www.google.com

위와 같은 메세지를 생성한다. (HTTP메세지의 자세한 내용은 차후 정리)

해당 메세지는 소켓라이브러리를 통해 전달되고 TCP/IP를 연결후에 데이터를 전달한 후에 HTTP메세지에 TCP/IP패킷을 감싼다.

해당 패킷은 네트워크계층으로 내려와 서버에 전송된다.

전송을 받은 서버는 HTTP요청 메세지에 대한 요청을 처리하고 아래와 같은 HTTP응답메세지를 생성하게된다.

    HTTP/1.1 200 OK
    Content-Type: text/html;charset=UTF-8 Content-Length: 3423

    <html> <body>...</body>
    </html>

보낼 때와 동일한 과정으로 TCP/IP패킷을 감사서 보내게된다.

html태그가 감싸진 html정보를 브라우저에게 전달하면 브라우저는 해당 파일을 렌더링해서 사용자에게 보여주게된다.

다음은 이제까지 설명하지않은 HTTP가 무엇인지 그리고 HTTP메세지에대해 설명하려한다.

HTTP
==
HTTP란 Hyper Tranfer Text Protocal의 약자로 위의 예시와 같이 클라이언트와 서버간의 통신에 사용되는 일종의 규칙이다.

위 예시에선 클라이언트와 서버간의 통신을 예로들었지만, 서버와 서버끼리 통신을 할 때에도 HTTP방식을 사용한다.

    HTTP/1.1 200 OK
    Content-Type: text/html;charset=UTF-8 Content-Length: 3423

    <html> <body>...</body>
    </html>

구글에 hello라는 검색을 한 결과 서버에서 웹브라우저에게 응답한 HTTP메세지인데, 하단에 html태그로 데이터를 전송한 것을 볼 수있다.

html파일 뿐만아니라 이미지, 영상,JSON(데이터),XML 등 다양한 형태의 데이터를 해당 칸에 적어 응답해준다.

**HTTP의 특징**

1. 클라이언트와 서버구조

웹브라우저와 서버간의 흐름을 봤듯이 HTTP는 요청을 보내고 응답을 보내는 방식으로 작동한다.

---

2. 무상태 프로토콜 (Stateful Stateless)

Stateful란 상태유지 Stateless란 무상태 라는 뜻이다.

상태유지란 사용자의 요청을 서버가 유지하고 있다는것이다.

    예시
    손님 1 : 사과 얼마인가요?
    점원 1 : 2000원 입니다.
    요청 2 : 2개 살게요.
    점원 1 : 4000원 입니다.

매우 자연스럽다고 느낄 수 있다. 하지만 만약 점원1이 바쁜일이 있어서 인수인계를 하지못하고 점원2가 손님1을 중간에 상대하게 됐을땐 문제가 발생한다.

    예시
    손님 1 : 사과 얼마인가요?
    점원 1 : 2000원 입니다.
    요청 2 : 2개 살게요.
    점원 2 : ?? 무엇을 2개 산다는 건가요??

이 처럼 점원이 바뀌면 상태유지에서는 처리할 방법이 없다.

즉 서버(점원1)가 중간에 죽어서 다른 서버(점원2)가 상대하게될때 문제가 발생한다.

그렇다면 **Stateless 무상태 프로토콜**이란 무엇일까?

애초에 손님이 요청을 보낼때 마다 이전 요청을 포함해서 같이 요청하는 방식이다.

    예시
    손님 1 : 사과 얼마인가요?
    점원 1 : 2000원 입니다.
    요청 2 : 사과 2개 살게요.
    점원 2 : 4000원 입니다.

점원이 바뀌었음에도 손님이 이전 요청을 포함시켜 요청하게되니 정상적으로 작동하게된다.

여기서 무상태프로토콜의 장점이 발견되는데, 갑자기 손님이 1000명이 들어와도 서버를 무한 증설해서 요청에 응답할 수 있게된다.

단점이라고 한다면 사용자가 요청을 보낼때 이전요청을 함께보내야한다는 점이다.

**단!** 실무에서 완벽한 무상태로 설계하기란 어려울 수 있다고 한다.

사용자의 로그인을 계속 유지시켜야하는 경우가 하나의 예시다.

---
 3. 비 연결성

TCP/IP에서 설명했듯이 TCP는 3 way handshake라는 논리적 연결을 통해 클라이언트와 서버가 연결된다.

여기서 연결을 끊지않고 지속해서 연결을 하게되면, 서버는 계속해서 사용자의 요청을 기다리고 자원을 소모하게된다.

이러한 비효율성으로 서버는 한 번의 요청에대한 응답이 이루어지면 TC연결을 종료하고 다른 사용자의 요청을 받는다.

하지만 요청이 들어올때마다 TCP연결을 해주어야하는 한계점들이 존재한다.

요즘은 HTTP 지속 연결(Persistent Connections)로 문제를 해결한다. 

예를들어 사용자가 html 요청, 이미지 요청, 자바스크립트 요청 을 각각따로 TCP연결을 통해 받는게 아니라 한 번의 연결을 통해 모든 요청에 대한 응답이 이루어지면 TCP연결을 끊게된다.

HTTP Message
==
위에서 웹브라우저와 서버간의 요청 응답에대한 흐름을 보았다.

HTTP메세지를 TCP/IP로 감싸 서로 주고받는 형태였는데 여기서 HTTP메세지란 무엇이고 어떻게 구성되어있는지 살펴보고자한다.

    HTTP 메세지의 구조

    start-line 시작 라인 
    header 헤더
    empty line 공백 라인 (CRLF) 
    message body

예시로 들었던 요청과 응답 메세지도 함께 보자.

    요청
    GET /search?q=hello&hl=ko HTTP/1.1 
    Host: www.google.com
    -------------------------------------
    응답
    HTTP/1.1 200 OK
    Content-Type: text/html;charset=UTF-8 
    Content-Length: 3423

    <html> <body>...</body>
    </html>

1. start-line 시작 라인

요청 메세지의 시작라인을 request-line이라고 한다.

HTTP메서드(GET=조회할 때 사용) 와 URI의 path/query-parameter를 적어주고 HTTP의 버전정보를 적는다.

응답 메세지의 시작라인은 status-line이라고 한다.

HTTP의 버전과 상태코드(200성공,400클라이언트 요청오류,500서버 내부오류) 와 짧은 메세지를 적는다.

>HTTP메서드는 뒤에서 설명하겠지만 GET POST DELETE UPDATE PUT 등 다양한 메서드가 존재한다.

2. header

헤더는 HTTP메시지의 다양한 부가정보를 담는다.

해당 메세지의 압축여부,메세지 바디의 크기,인증 등등..

3. HTTP body

실제 전송할 정보를 담는다. (html,이미지,영상,JSON 등)

HTTP 메서드
==
위에서 간략히 메서드의 종류엔 GET POST DELETE PUT 등 다수 존재한다고 했다.

좀 더 자세히 알아보고 우선 개발할때 URI의 설계에대해 알아보자.

1. 회원 목록 조회 /read-member-list 
2. 회원 조회 /read-member-by-id 
3. 회원 등록 /create-member
4. 회원 수정 /update-member
5. 회원 삭제 /delete-member

위와같이 URI를 설계했다면 과연 바르게 설계한 것일까?

언뜻봐서는 의미도 잘 들어오고 괜찮게 설계를 한것같지만, URI설계의 핵심은 리소스를 식별하는것이다.

    사과를 산다 의 리소스는?

위 문장은 리소스와 행위로 나눌 수 있다.

리소스는 "사과"가 되고, 행위는 "산다"이다.

URI설계의 핵심은 리소스를 식별한다고 했음으로 위 문장의 리소스는 사과이므로 사과자체를 리소스로 생각하고 설계해야한다.

회원 조회, 등록, 수정, 삭제 도 마찬가지로 리소는 회원이지 조회나 등록이 아니라는거다.
















