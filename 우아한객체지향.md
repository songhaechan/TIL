# 우아한 객체지향 조영호

객체들의 협력, 책임, 역할도 중요하지만

핵심은 의존성을 어떻게 관리하느냐.

같이 변경되는 것은 한 곳에, 아닌 것은 다른 곳에!

## 의존성이 도대체 무엇인가 [첫 번째 시간]

A ----- > B ( A depends on B , A가 B에 의존한다)

B가 변경되면

(클래스의 이름, 함수의 이름, 함수의 구현 등등)

A가 같이 따라 바뀐다.

즉, 변경에 의한 영향.

하지만! B의 구현이 변경된다해서 무조건 A가 영향 받는 것은 아니다.
(설계를 잘 한다면 ^^ )

## 의존성의 종류

4가지 정도가 존재한다.

1. 연관관계 Association

```java
public class A{
    // 영구적인 의존
    private B b;
}
```

2. 의존관계 Dependency

```java
public class A{
    // 해당 객체 타입을 반환하거나, 파라미터로 받는 경우
    public B doSomething(B b){
        // 해당 객체를 생성하거나
        return new B();
    }
}
```

객체의 일시적인 협력 시점에 의존성을 갖다가 헤어짐

3. 상속 관계 Extends

```java
// A가 B의 "구현"에 영향을 받는다.
// 물론 메서드 시그니처 변경, 파라미터 타입변경등에도 영향받음
public class A extends B{

}
```

4. 실체화 관계 Implements

```java
// A가 B의 메서드 시그니처에의해 영향을 받는다.
public class A implements B{
}
```

## 패키지 의존성

클래스 A를 열었더니 import로 다른 패키지가 존재한다면 패키지 의존성이 있다고 봐야한다.

a -- > b -- > c -- > a -- ... ????

의존성 사이클 절대 피해라.

변경이 돌고 도는 것은 하나의 패키지였어야함을 의미한다.

## 양방향 의존성을 피하라 (되도록!) 단방향으로 변경하자

양방향 의존을 갖는 경우 애초에 두 클래스가 하나의 클래스였어야 했을 것을 일부러 찢어놓은 것일 수 있다.

## 다중성이 적은 방향을 선택

JPA 다대일 일대다에서 양방향 매핑을 피하는 것이 좋은 이유와 같음

## 설계의 원칙이 뭐야

변경에 포커스를 맞춰라

내가 코드를 배치할때 이 녀석들이 어떻게 변경되고 누구에게 영향을 미치는지를 생각해라

## 런타임 그리고 협력

애플리케이션은 정적인 코드가 실행되는 순간부터 시간이라는 개념이 들어온다.

변화무쌍한 객체들의 협력관계들을 개발자는 정적인 코드로 녹여내야한다.

우리가 무심코 작성하는 코드들

인스턴스 변수를 선언하고,

메서드의 반환타입을 결정하고, 파라미터 타입을 결정하는 것은

모두 어떤 객체와 어떤 객체가 **협력하는 관계**를 결정하는 것이다.

## 관계는 방향성이다.

DB는 다르다. FK는 한쪽에 있으면 양쪽으로 이동이 가능!

하지만 객체는 또 다르다.

관계의 방향을 객체의 협력을 ! 결정해야한다.

## 연관관계와 협력

위에서 말했듯이

```java
public class A{
    // 영구적인 의존
    private B b;
}
```

객체 참조를 이용한 연관관계의 방향을 설정하는 대표적인 예시다.

이 말의 진짜 속 뜻은

두 객체의 관계가 영구적이라면,

A를 통해 B에 접근이 가능해야한다면,

또 빈번하게 접근해야한다면

연관관계를 설정하는 것을 고려해야한다.

이것을 객체 탐색경로를 만든다고 한다.

하지만 연관관계는 **개념**이고

이 **개념**을 구현하는 방법 중 한 가지가

위의 **객체 탐색**이다.(일반적인 방법)

다른 방법도 있다는 뜻이다.

개념과 구현은 구분하자.

## 그렇다면 영구적인 접근이 필요함은 어떻게 구분할까?

주문 엔티티를 생각해보자.

주문은 홀로 존재하지 않는다. 항상 어떤 가게에 종속된 주문만이 존재한다. 또한 주문은 항상 어떤 아이템들이 존재한다.

이러한 강력한 관계를 영구적인 접근으로 본다.

---

## 설계 개선하기 [2번째 시간]

카카오를 거쳐 배달의 민족을 거치신 조영호님께서도

직접 손으로 의존관계를 그리신단다...

나도 해야징 >\_<

처음부터 아름다운 구조는 없다.

더러워도 그냥 짜라.

그리고 개선해라, 그림을 그리던 어떻게 해서든 의존성을 파악하고 해소하고 개선하자.

## 중간객체를 이용해 의존역전(DIP)

DIP : 구체클래스 의존 no, 추상클래스에 의존

보통 추상화라하면 인터페이스나 추상클래스를 생각한다.

하지만 일반 객체로도 추상화 구조를 만들 수 있다.

추상화는 잘 변하지 않는 함수나 필드의 모음.

## 객체 참조의 문제

객체를 참조로 연관관계를 설정하면 많은 문제가 발생한다.(하지말라는게 아니고)

객체 참조는 그래프를 만들고, 하나의 객체에서 굉장히 멀리있는 객체까지 탐색이가능하다.

이렇게되면 ORM을 쓸 경우 어디까지 조회할 것인가 라는 성능 문제가 발생한다.(LAZY Loading)

트랜잭션도 롱 트랜잭션이 돼 버린다.

수정 범위도 모호해진다.

더 자세히 말하자면

하나의 트랜잭션에 물려있는 도메인이 3개라 해보자. Order, Shop, Delivery

이 셋은 분명 주문 로직에선 하나의 트랜잭션으로 묶여야할 것으로 보인다.

하지만 위의 각 도메인이 (DB테이블이) 주문로직만을 위해 존재하지 않는다.

배치 처리나, 어드민처리, 외부 요청으로 다양한 데이터베이스 업데이트를 처리해야하는데

롱 트랜잭션에 여러 도메인이 묶여있으면 그만큼 락을 많이 잡게되고 성능이 저하되기 매우 쉽다.

## 객체 참조 꼭 필요한가?

객체 참조 - Everything is connected

객체 참조는 결합도가 가장 높은 의존성이다.

**필요하다면 객체참조를 끊어내라**

## 리포지토리로 끊어내라

Order가 Shop을 객체 참조로 가지지 않고

Shop의 pk를 필드로 들고, Shop 리포지토리를 이용해 객체를 탐색하면 된다.

## 누구는 분리하고 누구는 결합해도 되는가?

같이 생성,삭제되는 객체들

도메인 제약사항을 공유하는 객체들

가능하다면 ! 분리해라

## 필드를 pk값으로 바꾸고 나서 떨어지는 컴파일에러

도메인 로직에서 아직 사용중인 객체참조는 이제 수정해야만한다.

더 이상 참조할 객체가 없기 때문

이 도메인 로직을 다른 객체로 옮겨야한다.

예시에서는 검증 로직인데, 검증 객체를 따로 만든다.

## 응집도란

변경의 관점으로 생각을 하자

같이 변경되는 것들(연관된 것들)이 많을 수록 응집도가 높다. [단일 책임 원칙]

객체안에 validation 로직을 무조건 넣을 필요없다. (응집도를 낮출 수 있다. but 간단한 것은 괜찮다)

## 메서드를 만들었기 때문에 메세지를 보내는게 아니라 메세지를 보내야하기 때문에 메서드를 만드는 것이다.
