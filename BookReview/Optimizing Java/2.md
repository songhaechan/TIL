인터프리팅과 클래스로딩
=

### JVM 인터프리터는 평가 스택(메서드 호출스택, 중간계산결과)를 사용해 옵코드(특정연산 조작)를 하나씩 순서대로 처리한다.

> 스택에서 연산 중간결과를 하나씩 꺼내어 옵코드로 연산


### 클래스 로딩 메커니즘

부트스트랩 클래스(JVM이 실행되기위한 핵심 클래스 로드 object,class,classloader) 실행

확장 클래스로더 생성(부트스트랩 클래스의 자식)

애플리케이션 클래스로더(확장 클래스로더의 자식)

> ClassNotFoundException이 위 메커니즘에서 발생한다. 애플리케이션 클래스가 없으면 계속해서 부모에게 떠넘기는데 부트스트랩도 찾지못하면 발생하는 예외다.

바이트코드 실행
=

우선! Java는 플랫폼에 의존적이지않지만 JVM은 플랫폼에 의존적이다. (리눅스,윈도우 각자 JVM이 다름 하지만 .class만 있다면 같은 .class로 실행이 가능함)

즉 컴파일만 됐다면, 어떤 플랫폼에서도 실행이가능하다.(JVM이 특정 OS에 설치됐다면)

순서

.java 파일 -> javac(컴파일러) -> .class(바이트코드)

.class에는 클래스명, 부모 클래스, 클래스 종류 등등 여러가지 컴포넌트가 있다.

JIT 컴파일
=

javac가 컴파일한 .class파일은 기계어가 아닌 자바 바이트코드라고 불리는 JVM의 인터프리터가 해석가능한 코드들로 이루어져있다.

javac가 컴파일하기도하고 자바 바이트코드를 인터프리터가 한줄씩 해석하기도하기때문에 java를 하이브리드 언어라고도 불린다.

자바의 클래스로더는 한번에 모든 클래스를 로드하지않고 동적으로 로드하기때문에 인터프리터가 그때 그때 한 줄씩 해석하는데 이때 자주 사용되는 코드는(임계점을 넘은 코드) **JIT컴파일러의 프로파일러**가 미리 컴파일해서 코드를 캐싱한다.

JVM 메모리관리
=

JVM은 GC를 이용해 힙영역의 메모리를 관리한다.

GC가 돌면 매우 짧은 시간이지만 어플리케이션이 중단된다.

성능최적화의 중심 주제이기때문에 이후에 자세히 다룬다.

스레딩과 자바 메모리 모델 JMM
=

자바의 스레드는 하나의 전용 OS스레드에 대응된다.

