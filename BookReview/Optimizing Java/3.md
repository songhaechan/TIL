메모리
=

트랜지스터의 개수가 늘어나면서 CPU와 메모리사이의 성능차이가 심했다.

CPU의 클럭속도(더 많은 명령어 처리가 가능함)가 높아져도 가져오는 데이터의 속도가 느리다보니 그 속도를 원활히 사용할 수 없었다.

### 메모리 캐시

그래서 등장한 것이 CPU에 있는 메모리를 만들자는 것이였다.

CPU내부의 레지스터보단 느리지만 메인메모리보단 빠른 메모리다.

흔히 CPU와 가까운 L1 L2 순으로 명명하는 CPU 캐싱 메모리이다.

메인 메모리보다 L1캐시가 약 40배 넘게 차이난다.

### 캐시 일관성 프로토콜

또 다른 문제는

메모리에 있는 데이터를 캐시로 가져오고 캐시한 데이터를 다시 메모리에 쓰는 방법을 결정해야했다.

둘 이상이 동시에 공유상태이더라도 한 프로세서가 배타나 수정 상태로 바뀌면 다른 프로세서는 강제로 무효상태가된다.
>MESI 참고

요즘 프로세서는 **후기록** 방식을 채택한다.

DB에서 더티페이지만 디스크에 기록하는 방식과 유사하게 변경된 캐시 블록만 메모리에 기록한다.

최신 프로세서
=

### TLB

캐시가 메모리에 빠르게 액세스하기위해 실제 메모리주소를 미리 캐싱해두는 버퍼를 말한다.

프로그램 코드와 데이터는 가상메모리공간에 배치하고 실제 메모리주소를 같이 적어놓고 필요할때 액세스하는 방식이다.

### 분기예측과 추측 실행

분기 예측은 조건문이나 루프등을 실행할 때 다음 명령어를 예측하는 것을 말한다.(지연을 최소화하기위해)

### 하드웨어 메모리 모델

서로 다른 스레드가 일관되게 동일한 메모리 주소를 액세스할 수 있을까?

```java
myInt = otherInt;
intChanged = true;
```

JIT컴파일러는 위 코드의 순서를 바꿀 수 있다.

현재 스레드는 저 두 코드의 순서가 바뀌어도 아무런 상관이 없지만 다른 스레드가 순서가 바뀐 코드를 보면 이전 값인 myInt를 읽을 수도 있다.

멀티스레드를 이해하려면 락과 volatile를 정확히 알고 사용해야한다.

운영체제
=

### 스케줄러

OS는 스케줄러를 이용해서 CPU 액세스를 통제한다.

이때 실행큐에 스레드를 대기시키는 큐를 이용한다.

중요한 점은 하나의 스레드가 자신의 할당시간을 다 소모하면 실행큐 맨 뒤로 이동해 다시 CPU로 들어가기까지의 시간이 소요된다는 것인데

이 대기 시간이 스케줄링 오버헤드라고 한다.

예를들어 1밀리초씩 1000번 재우고(스레드는 재우면 실행큐 맨뒤로 돌아간다) 시간을 측정했을 때 2초라면 1초는 실행시간 1초는 대기시간임을 알 수 있다.

### 시간

JVM을 올린 OS마다 시간에도 차이가있다.

맥,리눅스,솔라리스는 대부분 시간을 측정하는 함수가 거의 같다.(OS에 의존적인 네이티브 코드로 구성됨)

하지만 유독 윈도우만 다른 방식으로 시간을 측정한다.

즉 OS에따라 작동이 상이해진다.(같은 코드라 할 지라도)

### 컨텍스트 교환

유저 스레드간의 컨텍스트 스위치보다 유저 스레드에서 커널모드로 교환될때 컨텍스트 교환 비용은 더 비싸진다.

커널모드는 유저모드와 다르게 공유해야할 메모리,캐시가 거의 없기때문에 아예 비우고 새롭게 시스템콜로 가져와야하는데 이 비용이 상당히 비싸다.

다시 유저모드로 돌아갈 때에도 마찬가지다.

리눅스는 이 비용을 최대한 감소시키기위해 **가상 동적 공유 객체**를 이용한다. (커널모드로 컨텍스트를 교환하지 않게된다)

기본 감지 전략
=

### CPU 사용률

CPU는 부하가 집중되면 100%를 사용해야한다. (놀고있으면 안된다는 뜻)

vmstat를 터미널에 입력하면 여러 지표를 확인할 수 있다.

그 중에서 컨텍스트 교환 발생횟수를 알 수 있는데 CPU사용률이 100%도 아닌데 컨텍스트 교환 발생이 잦다면 스레드 락 경합이 일어났을 가능성이 크다.

이와 더불어 VisualVM을 사용하면 프로세스의 스레드 상태를 체크할 수 있다.

### 가비지 수집

JVM은 시작과 동시에 메모리를 유저공간에 할당하고 관리하기때문에 GC가 작동한다고 커널 교환(OS에 시스템콜) 하지는 않는다.

즉 어떤 시스템의 CPU사용률이 100%라면 GC의 문제는 아니지만 유저 공간에서 CPU사용률이 100%라면 의심해봐야한다.

이때 GC로그를 살펴보면 많은 도움이되고 운영 환경에서는 필수적이다.

### 가상화

호스트 OS위에서 게스트OS를 작동시키는데 보통 비가상화OS는 하드웨어를 직접 건드릴 수 있지만 가상화 OS에서는 프리빌리지모드로 동작하지않기때문에 직접 접근이 불가능하다.

### JVM과 운영체제

자바에서 시간을 얻는 코드는 OS에 종속적임을 설명했었다.

똑같은 코드를 사용하더라도 OS에따라 호출하는 메서드가 다르다.

이런 코드들은 네이티브 메서드로 이루어져있다.

이 작업을 대행하는 인터페이스를 자바 네이티브 인터페이스라고 한다.

