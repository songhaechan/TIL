URL 단축기 설계
=

시스템의 기본적 기능

1. 긴URL을 짧게 줄인다.
2. 짧은 URL 요청이 오면 긴 URL로 리다이렉션한다.
3. 높은 가용성과 규모 확장성, 장애 감내 요구

초당 쓰기연산은 **1160**건 이다.

10년간 운용한다면 **3650억** 개의 레코드를 보관해야한다.

## 301,302 리다이렉션의 차이점

### 301 Redirection

301은 Permanently Moved로 해당 요청의 책임이 영구적으로 Location헤더에 반환된 URL로 이전됐다는 의미다.

즉 브라우저는 첫 요청에만 단축 URL로 요청을 보내고 다음 요청부터는 캐시된 URL로 요청을 보낸다.

서버자원을 많이 소모하지는 않지만 트래픽 분석에는 용이하지않다.

### 302 Redirection

일시적으로 리다이렉션을 해주기때문에 브라우저에서 따로 캐시하지않는다.

모든 요청마다 단축 URL에 요청을 보내게된다.

### 개략적인 설계에서는 해시테이블에 긴URL 짧은URL을 key-value 쌍으로 저장한다.

## URL 단축

긴 URL -> 해시함수 -> https://tinyurl.com/{hashValue}

1. 긴 URL이 다르면 hashValue도 달라야한다.

2. 해시 값은 원래 긴 URL로 복원이 가능해야한다.

## 상세설계

개략적 설계에서느느 해시테이블에 key-value로 저장했지만 대규모 시스템에서는 쓰기 매우 곤란하다.

메모리에 그 많은 url쌍을 저장한다는건 비용 측면에서 부담이 된다.

### RDB를 사용해보자.

RDB에 PK, 긴URL, 짧은URL 세 컬럼을 두고 저장하는 방법이다.

자 이제 **해시함수를** 어떻게 구성할지 알아보자.

시스템 요구사항에서 hashValue는 **짧으면 짧을 수록 좋고, 숫자와 대소문자 알파벳을 사용해야한다.**

즉 0-9(10개), a-z(26개), A-Z(26개) **총 62개**이다.

우린 10년동안 서비스를 제공한다고 가정하고 총 3650억개의 url을 중복없이 저장해야한다.

62에n >= 3650억 을 만족시키는 n값을 찾아야한다.

찾아보면 n=6일땐 약 56억개의 url을 생성할 수 있다. (너무 작다)

n=7일땐 약 3.5조의 url을 만들 수 있다.

넉넉하게 **7로** 잡자.

해시함수를 구현할 방법은 **해시 후 충돌 해소**와 **base-62** 변환법이다.

## 해시 후 충돌 해소 방법

이제 긴 URL을 해시함수를 이용해 7자리로 줄여야한다.

CRC32, MD5, SHA-1과 같은 해시함수를 이용할 수 있는데 CRC32가 가장 짧은 해시값을 제공한다.

임의의 긴URL을 해싱한 해시값 : "**5cd54054**"

그런데 5cd54054는 8자로 7자를 넘는다.

**해시 후 충돌 해소**를 적용하면 이를 해결할 수 있다.

5cd54054에서 4를 제거하고 5cd5405 까지만 사용한다.

그런데 이렇게하면 5cd5405라는 해시값을 가진 다른 URL과 충돌될 수 있다.

만약 **DB에 질의 후** 충돌된다면 긴URL에 미리 정해둔 문자열을 덧붙여서 다시 해싱하고 **DB에 다시 질의**한다.

문제점은 뻔하지만 DB에 무조건 질의를 해야하고 운이 좋지않다면 2번 이상 질의해야할 수 있다.

이 방법을 해소할 수 있는 아주 좋은 기술이 있다.

바로 **블룸필터를** 사용해 DB에 질의하지않는 것이다.

### 블룸필터

블룸필터는 m개의 비트배열을 가지고 k개의 해시함수를 가진다.

![img](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcnNUFn%2FbtrG3KV0rZC%2FD4Oq5vbZJBCKMROIhigiBk%2Fimg.jpg)

위 블룸필터는 17개의 비트를 가지고 5개의 해시함수를 가진다.

100을 입력하면 5개의 해시함수를 통해 해시결과를 배열의 인덱스에 1로 교체한다.

55를 입력하는 경우도 똑같이 익덱스를 1로 교체한다.

즉 해당 블룸필터의 원소는 100과 55 두개를 가진다.

만약 100과 55를 조회하면 (해시함수는 절대 변해서는 안된다.) 해시함수를 통해 값을 계산하고 비트배열이 모두 1로 확인되기때문에 참을 반환한다.

88을 조회하면 비트배열에 0이 존재하기때문에 거짓을 반환한다.

**만약 100과 55는 아니지만 모든 비트배열이 1로 동일한 수가 조회한다면?**

만약 32를 조회했는데 해시함수결과가 모두 1인 인덱스를 가르킬 수 있다.

이 경우엔 블룸필터는 존재한다고 답한다.

이를 **거짓-긍정**이라한다.

블룸필터의 원소집합의 개수가 많아지면 많아질 수록 거짓-긍정이 발생할 확률이 높아진다.

이렇게 블룸필터는 확률에 기반하기에 **확률형 자료구조**라고 불린다.

### 어떤 상황에서 사용되면 좋을까?

단축 URL 설계 시 같은 url이 집합에 속하진않지만 속한다고 답하는 것은 큰 문제가 되지않는다.

속하는데 속하지않는다고 답변하는 것은 절대 발생할 수 없는 블룸필터의 특징상 아주 적합하다.

또 닉네임이 중복되는지 체크하는 경우에도 사용하기 적합하다.

중복되지않지만 중복된다고 하는 것은 그리 큰 문제가 되지않는다.

하지만 이메일주소를 기반으로 블룸필터를 사용하면 문제가될 수 있다.

가입한 적도 없는데 내 이메일이 이미 가입됐다고하는 것은 서비스 특성상 큰 문제가 발생할 수 있다.

이런 경우는 블룸필터를 사용해서는 안된다.

## base-62 변환

62진법은 지금 시스템 설계에 매우 적합하고 다른 시스템에서도 자주 사용하는 기법이다.

우선 62개의 문자를 사용해야하는 현재 요구사항에 매우 적합하다.

11157은 62진법으로 표현하면 2TX가 된다.

## 두 방식의 차이점

위에서 봤듯이 base-62는 **7자리로 고정이 불가능**하다.

이 설계는 DB에 저장하고 반환된 ID값을 기준으로 변환하기에 ID가 커지면 단축 URL은 같이 커진다.

ID의 유일성이 보장만 돼있다면 충돌가능성이 없다.(해시 후 충돌 해소 전략은 충돌가능성이 있음, 해소는 가능)

ID가 1씩 증가한다면 다음 쓸 URL을 알 수 있기에 보안상 문제가 있다.(base-64는 암호화 알고리즘이 아니라 단순변환 기술이다.)

## 단축기 상세 설계

우선 우린 base-64변환을 이용해 설계한다.

1. longURL 요청
2. DB에 해당 longURL에 매칭되는 shortURL이 있는지 질의
3. 있다면 찾아서 반환
4. 없다면 새로운 ID를 생성
5. ID를 통해 base-64로 변환 후 저장

## URL 리다이렉션 상세 설계

1. 단순 url로 요청이 온다.
2. 로드밸런서가 웹서버에 요청을 전달
3. 캐시를 먼저 찾고 없다면 DB에 질의
