- [키-값 저장소 설계](#키-값-저장소-설계)
  - [단일 키-값 저장소](#단일-키-값-저장소)
  - [분산 키-값 저장소](#분산-키-값-저장소)
    - [CAP (consistency,availability,partition tolerance)](#cap-consistencyavailabilitypartition-tolerance)
    - [데이터 일관성](#데이터-일관성)
    - [가용성](#가용성)
    - [파티션 감내](#파티션-감내)
    - [데이터 일관성 + 파티션 감내 (CP)](#데이터-일관성--파티션-감내-cp)
    - [가용성 + 파티션 감내 (AP)](#가용성--파티션-감내-ap)
  - [데이터 파티션](#데이터-파티션)
  - [데이터 다중화](#데이터-다중화)
  - [데이터 일관성](#데이터-일관성-1)
    - [정족수 합의](#정족수-합의)
    - [R=1, W=N](#r1-wn)
    - [R=N, W=1](#rn-w1)
    - [W+R\>N](#wrn)
    - [W+R\<=N](#wrn-1)
    - [강한 일관성 모델](#강한-일관성-모델)
    - [최종 일관성 모델](#최종-일관성-모델)
    - [데이터 버저닝](#데이터-버저닝)
    - [장애 감지](#장애-감지)
    - [일시적 장애 처리](#일시적-장애-처리)
    - [영구 장애 처리](#영구-장애-처리)
  - [쓰기 경로](#쓰기-경로)
  - [읽기 경로](#읽기-경로)

키-값 저장소 설계
=

키-값 저장소는 비관계형 데이터베이스이다.

키는 유일해야하고 값은 객체,텍스트,이미지 등등 다양하게 저장이 가능하다.

## 단일 키-값 저장소

키-값 쌍을 모두 메모리에 해시테이블로 저장한다.

일단 메모리 부담이 있을 수 있다. -> 데이터 압축, 자주 쓰는 데이터만 메모리에 저장

하지만 이렇게 한다고 한들 이 서버가 죽으면 대처가 불가능하다.

결국은 다중화시켜야한다.

## 분산 키-값 저장소

CAP정리부터 알아보자

### CAP (consistency,availability,partition tolerance)

CAP 정리는 데이터 일관성, 가용성, 파티션감내 이 세 가지 요구사항을 모두 만족시키는 것은 불가능하다는 정리다.

우선 세 가지 요구사항을 알아보자.

### 데이터 일관성

분산 시스템에 접속하는 클라이언트는 어떤 노드에 접속하더라도 같은 데이터를 보아야한다.

### 가용성

일부 노드가 죽더라도 항상 응답을 받아야한다.

### 파티션 감내

노드끼리의 통신장애가 발생하더라도 시스템은 계속 동작해야한다.

---
실제 서버에서 파티션 감내를 하지 못하는 서버는 있어서는 안된다.

한 노드가 죽었는데 모든 서비스가 마비되는 것은 상식적으로 일어나서는 안되는 일이다.

이렇게된다면 선택지는 두 가지다.

### 데이터 일관성 + 파티션 감내 (CP)

CP는 가용성을 희생한다.

가용성을 희생한다는 것은 장애가 발생했을때 클라이언트가 **응답을 못받는 상황을 허용**한다는 것이다.

n1,n2,n3 중 n3에 장애가 발생했다면 n1,n2의 모든 쓰기연산을 중단시킴으로써 **데이터일관성**을 만족시킨다.

하지만 쓰기를 중단시킨다는 것은 **가용성**을 포기한다는 뜻이다.

은행의 경우 데이터 일관성을 포기하지 못한다. 민감한 계좌정보에대해 일관된 데이터를 제공하지 못 할바엔 오류페이지를 계속 띄우는 것이다.

### 가용성 + 파티션 감내 (AP)

AP는 데이터 일관성을 희생한다.

데이터 일관성을 희생한다는 것은 장애가 발생했을 때 클라이언트가 **낡은 데이터를 반환받는 것을 허용**한다는 것이다.

파티션 문제가 해결됐을 때 새 데이터를 n3에 전송함으로써 문제를 해결한다.

## 데이터 파티션

전체 데이터를 한 서버에 몰아넣는 것은 불가능하다.

이 문제를 부드럽게 해결하는 방법은 직전 장에서 살펴봤다.

안정해시 설계를 통해 해시 링 위에 가상의 노드들과 함께 서버를 배치하고 시계방향으로 돌며 만나는 첫 서버에 데이터(키-값)을 저장한다.

## 데이터 다중화

데이터 파티셔닝은 다른 데이터를 다른 서버에 분산시키는 것이다.

데이터 다중화는 **같은 데이터를 다른 서버**에 분산시키는 기법이다.

이 기법도 안정해시를 통해 설계할 수 있다.

기존에는 시계방향으로 돌며 만나는 첫 서버에만 데이터를 저장했다면, 다중화는 돌며 만나는 첫 N개의 서버에 데이터를 저장한다.

가상화 노드서버 때문에 데이터가 일관되게 골고루 분포되지않을 가능성이 있는데 이 점을 주의해야한다.

## 데이터 일관성

다중화가 완료됐다면 이 데이터들은 적절한 **동기화**가 필요하다.

**정족수 합의** 프로토콜을 사용해 읽기/쓰기 모두 일관성을 보장할 수 있다.

### 정족수 합의

N은 사본 개수

W는 쓰기 연산에 대한 정족수 (쓰기 연산이 성공하려면 적어도 W개의 서버로부터 성공응답이 필요)

R는 읽기 연산에 대한 정족수 (읽기 연산이 성공하려면 적어도 R개의 서버로부터 성공응답이 필요)

### R=1, W=N

읽기는 한 대의 서버만 성공응답이 온다면 성공으로 간주한다.

하지만 쓰기는 N개의 서버가 모두 성공응답이 와야 성공으로 간주된다.

즉 빠른 읽기 연산에 최적화돼있다.

### R=N, W=1

같은 맥락으로 빠른 쓰기 연산에 최적화돼있다.

### W+R>N

강한 일관성을 보장한다.

### W+R<=N

약한 일관성을 보장한다.

### 강한 일관성 모델

강한 일관성은 서버들로부터 성공응답을 상대적으로 많이 받아야 성공으로 간주된다.

일반적으로 모든 사본에 현재 쓰기연산의 결과가 반영될때까지 읽기/쓰기를 금지한다.

DB에 Lock을 거는것이다.

성능상에 문제가 있을 것이 뻔하다.

### 최종 일관성 모델

이 모델은 병렬적 쓰기를 허용한다.

그렇다면 일관성이 깨질 수 있는데 이 문제는 **데이터 버저닝, 벡터 시계**로 해소한다.

### 데이터 버저닝

n1,n2 에 key-value={name, john} 있다고 가정해보자.

서버 1, 서버 2가 각각 n1,n2에 접근해 name을 A와B로 변경했다.(병렬로)

이 두 데이터 중 어느 데이터를 신뢰할 수 있을까?

john이라는 값은 무시되겠지만 A와B 사이에 존재하는 비일관성을 해소해야한다.

벡터시계는 이 비일관성을 해소한다.

[서버,버전] 으로 나뉜 값을 데이터에 메달아 놓는 것이다.

이렇게 어떤 서버가 어떤 데이터를 어떤버전으로 업데이트했는지를 추적해서 충돌되는 데이터간의 비일관성을 **클라이언트 측이 해소**한다.

### 장애 감지

서버노드 5개가 있을 때 이 모든 서버가 서로 통신한다는 것은 비효율적일 수 있다.

**가십 프로토콜 같은 분산형 장애 감지**솔루션을 선택하자.

각 노드는 모든 노드가 송신하는 신호와 신호발생 시각을 저장하는 테이블을 가지고있다.

각 노드들은 **임의로** 선택된 서버들에 자신이 살아있다는 신호를 보낸다.

어떤 노드의 신호발생시각이 오랫동안 갱신되지않으면 자신이 가지는 테이블을 임의의 노드에게 보낸다.

모든 노드가 이 상황을 인지한다면 장애발생으로 간주한다.

### 일시적 장애 처리

장애가 발생했다면 장애가 발생한 노드에 들어오는 요청을 다른 노드가 처리해야한다.

장애가 발생한 노드에대한 요청이라는 표식을 남긴다.

장애가 해결되면 표식이 남은 데이터를 인계한다.

이 것을 **단서 후 임시 위탁 기법**이라 부른다.

### 영구 장애 처리

영구적으로 장애가 발생한 경우엔 **반-엔트로피 프로토콜**을 이용해서 처리한다.

키 공간을 버킷으로 나누고 키를 해쉬 함수를 이용해 해쉬값을 구한다.

그 후 각 버킷의 해쉬값을 구한다.

각 버킷의 해쉬값의 해쉬값을 구하고 이진 트리를 상향식으로 구성해나간다.

만약 루트노드 해쉬값이 같다면 두 서버는 정확히 동일한 데이터를 가지고있는 것이다.

다르다면 좌우측 노드를 탐색하며 일관되지않는 키를 찾아 복사한다.

## 쓰기 경로

클라이언트가 쓰기 요청하는 과정이다.

1. 커밋 로그에 로그를 남김
2. 메모리 캐시에 기록
3. 디스크에 Flush
   

## 읽기 경로

1. 우선 메모리를 뒤진다.
2. 없다면 블룸필터를 거쳐 어떤 데이터센터에있는지 찾는다.
3. 데이터센터에서 결과데이터를 가져와 반환한다.