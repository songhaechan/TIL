데이터베이스 수평적 확장
=

데이터베이스를 분할하는 방법은 크게 **샤딩**과 **파티셔닝**이 있다.

## MySQL 파티셔닝 

InnoDB에서 지원하는 파티셔닝에대해 알아보자.

파티셔닝은 하나의 **큰 테이블**을 서브테이블로 나누어 저장하는 방법이다.

큰 데이터가 나뉘기때문에 쿼리 성능이 개선될 수 있다.

데이터가 특정 목록에 포함되는 **리스트 파티셔닝**(ex 주소를 기반으로 저장)

데이터가 특정 범위에 저장되는 **범위 파티셔닝**(ex 시간을 기준으로 저장)

특정 컬럼을 해싱하여 저장하는 **해싱 파티셔닝**이 있다.

## 샤딩

위 파티셔닝은 하나의 컴퓨터(하나의 서버)에서 테이블을 분할하는 작업이다.

샤딩은 Scale-Out 방식이다. 즉 서버자체를 수평적으로 확장한다.

물리적인 서버가 다르기때문에 조인하는 것은 불가능하다.

서로 다른 MySQL서버는 조인할 수 없듯 같은 맥락이다.

샤딩에서 발생할 수 있는 문제는 서버가 증설되거나 제거될때 **재 샤딩**이 필요한데 이 문제는 **안정 해시 설계**로 극복이 가능하다.

## 분산 시스템을 위한 유일 ID 생성기 설계

데이터베이스를 분산한다는 것은 여러대의 서버로 수평적 규모확장을 한다는 의미다. 즉 샤딩을 통해 (안정해시설계와 함께) 물리적으로 다른 서버에 데이터를 저장한다.

물론 고가용성을 위해 안정해시설계에서 다중화처리도 가능하다.

분산 시스템에대해 가볍게 되새겼으니 ID 생성기 설계를 생각해보자.

요구사항은 아래와 같다.

1. ID는 유일해야한다.
2. 숫자로만 구성되어야 한다.
3. 64비트로 표현될 수 있는 값이어야 한다.
4. ID는 발급 날짜에 따라 정렬 가능해야한다.
5. 초당 10000개의 ID를 생성할 수 있어야한다.

어디까지나 책에서 제시하는 시스템 요구사항이고 서비스마다 달라질 수 있다는 것을 명심하자.(정답이 아니란 이야기)

### 다중 마스터 복제

auto_increment를 활용하는 방법이다.

1번 데이터서버는 1,3,5 로 ID를 증가시키고

2번 데이터서버는 2,4,6으로 ID를 증가시킨다.

증가하는 k값은 데이터서버의 개수이다.

k가 3이라면 1,4,7로 증가한다.

요구사항 중 1번,2번,3번,5번은 만족이 가능하다.

유일하고 숫자로만 구성되며 64비트로 표현도되고 초당 10000개의 ID를 생성할 수 있다.

(초당 10000개의 ID를 생성하기위해선 데이터서버를 증설하면 된다.)

**하지만 중대한 문제가 있다.**

1. 중간에 서버가 추가되거나 삭제되면 데이터를 재배치해야한다.

2. 4번 요구사항을 만족할 수 없다. ID의 값이 순서를 보장하지 못하기 때문이다.

### UUID

매우매우 간단하고 단순한 방법이다.

128비트짜리 수로 유일하게 식별이 가능한 ID를 서버가 **각자** 생산한다.

위 다중 마스터 복제처럼 다른 서버와의 조율은 필요없다.(**규모확장이 쉽다.**)

왜냐하면 128비트짜리 UUID가 1개 중복생성될 확률을 50%까지 올리려면 초당 10억개의 ID를 100년동안 계속해서 만들어야하기때문이다.

(**그만큼 중복될 확률이 없기때문에 다른 서버를 고려하지않아도 된다.**)

하지만 요구사항 중 64비트를 만족시키지못하고 시간순으로 정렬도 불가능하다. 또한 숫자가 아닌 값이 포함될 수 있다.

### 티켓 서버

이 아이디어도 auto_increment를 사용한다.

다중 마스터 복제와 다른 점은 **하나의 서버**를 중앙 집중형으로 사용한다.

SPOF문제가 발생할 수 있지만 구현이 매우 쉽고 유일성도 보장된다.

SPOF를 해결하기위해 티켓서버자체를 다중화할 수는 있겠지만 그렇게되면 당연히 모든 웹서버가 공유하기때문에 **동기화 문제**를 해결해야한다.

### 트위터 스노플레이크 접근법

우선 64비트를 여러 절로 분할한다.

1. 사인 비트 : 1비트를 할당하고 음수 양수를 구별한다.(지금으로서는 필요없다)

2. 타임스탬프 : 41비트를 할당한다. 기원 시각(서비스 시작시간)이후로 몇 ms가 경과했는지 나타낸다.

3. 데이터 센터 ID : 5비트를 할당하고 32개의 데이터센터를 표현할 수 있다.

4. 서버 ID : 5비트를 할당하고 32개의 서버를 표현할 수 있다.

5. 일련번호 : 12비트를 할당하고 서버가 ID를 생성할 때마다 1만큼 증가시킨다. **흥미로운 점은 1ms가 경과할때마다 0으로 초기화된다.**

5번째 절에따르면 1ms에 2에12승 만큼의 일련번호가 할당가능하다. 2에 12승은 4096이고 1초라면 4096000개의 ID를 할당이 가능하다.(이론상)

> 일련번호에 할당된 비트가 너무 큰 것같다.

### 마무리

트위터 스노플레이크 접근법의 **타임스탬프는** 물리적으로 다른 서버라면 달라지 가능성이 있다.(당연함 미국과 한국의 시간은 다르니까)

이런 문제가 있다는 것은 알아두자 이문제는 NTP를 이용해 해결이 가능하다.

각 절의 비트 수는 서비스에 따라 다르게 작성할 수 있다. 동시성이 낮다면 일련번호의 비트를 줄이고 타임스탬프를 늘리는것이 오랫동안 서비스를 제공할 수 있을 것이다.

