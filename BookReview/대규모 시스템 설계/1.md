사용자 수에 따른 규모 확장성
=

## 단일 서버

단순하게 웹 서버 한 대 안에서 모든 처리가 이루어진다.

    DNS에 IP질의 -> IP를 통해 웹서버에 요청 -> 웹서버의 응답

매우 단순한 형태이다.

## 데이터베이스

사용자가 늘어난다면 가장 먼저 데이터베이스를 웹서버로부터 분리해야한다.

그 이유는 독립적인 계층 구조를 가져야 각 계층이 독립적으로 **확장**이 가능하기때문이다.

### 어떤 데이터베이스를 사용할까?

- RDBMS : 관계형 데이터 베이스의 핵심은 그 이름이 그렇듯 관계에 있다. 여러 스키마를 가지고 서로 다른 스키마를 조인할 수 있다.

- NoSQL : 비관계형 데이터베이스

### 비 관계형 데이터베이스의 선택

- 낮은 응답지연시간 (빠르게 답변해야할 때)

- 데이터가 비정형일 때 (동영상,이미지,텍스트 등등)

- 데이터를 직렬화하거나 역직렬화 할 수 있기만 하면 될 때(NoSQL은 조인 불가능)

- 많은 양의 데이터

## 수직적 규모 확장 vs 수평적 규모 확장

수직적 규모 확장은 Scale Up 이라 불리고 말 그대로 성능을 향상시키는 방법이다.

하지만 **CPU나 메모리를 올리는데는 한계**가 있다.

또한 다중화없이 수직적으로 확장하면 **한 포인트에서 장애가 발생했을때 완전히 서비스가 중단**된다.

수평적 규모 확장은 Scale Out 이라 불리고 데이터베이스의 그 수를 늘리는 것이다.

**규모가 큰 서비스는 수평적 규모 확장이 옳다**

## 로드밸런서

지금 우리 예제는 아직 웹서버가 단 한 대밖에 없다.

웹서버에서 병목이 발생하거나 장애가 발생하면 문제가 심각해진다. 우회할 서버도 없기때문이다.

이때 로드밸런서를 도입한다.

**부하 분산 집합** 속에 웹서버를 다중화한다.

로드밸런서는 사용자의 요청을 가장 먼저 받고 그 후에 웹서버들에게 요청을 고르게 전달한다.

이때 **웹서버들은 사설 IP를 사용하고 로드밸런서는 공인 IP를 사용하여 웹서버의 보안을 증대**시킬 수 있다.

이제 웹서버 하나가 죽어도 다른 웹서버로 우회하여 장애에 대응할 수 있게되고, 병목현상도 줄어들 것이다.

## 데이터베이스 다중화

데이터베이스는 **master(주)-slave(부)** 관계를 설정하는 할 수 있다.

주 데이터베이스에는 insert,delete,update 등 자원에 변경이나 생성을 가하는 쿼리를 집중적으로 담당하고, 부 데이터베이스는 오로지 조회만을 위해 배치한다.

보통 조회작업이 80%이상을 차지한다고한다. 그렇기에 부 데이터베이스를 주 데이터베이스보다 더 많이 두는 것이 일반적이다.

- 다중화는 질의를 병렬로 처리하여 성능이 올라간다.

- 안정성 : 자연재해로 물리적으로 소멸된 DB의 데이터를 보존할 수 있다.

- 가용성 : 하나가 죽어도 우회가 가능하다.

### 주 데이터베이스가 죽어도 부 데이터베이스에서 일시적으로 주 데이터베이스 역할을 할 수 있고, 부 데이터베이스가 죽으면 다른 곳으로 우회하고 그 사이 새로운 부 데이터베이스를 증설할 수 있다.

## 캐시

**애플리케이션의 성능은 DB를 얼마나 자주 호출하느냐에 크게 좌우된다.**

그렇기에 자주 사용되는 데이터나 비싼 데이터들은 미리 메모리에 올려두고 보다 빠르게 처리될 수 있도록한다.

캐시는 DB앞단에서 먼저 요청을 받고 해당 데이터가 없을 경우에만 DB에 요청한다.

### 캐시 사용시 유의할 점

- 데이터의 변경보다 참조가 많아야한다.(데이터 부정합 가능성)

- 중요데이터는 옳지 못하다. 캐시는 메모리에 올라가기때문에 휘발된다.

- 만료 정책을 정해야한다. 너무 짧아도 않되고 너무 길어도 안된다. (너무 길면 원본과의 차이가 벌어질 가능성이 있다.)

- 원본과 캐시의 사본 사이의 일관성을 어떻게 해결할까? 책 참고[7]

- 캐시 서버가 한 대라면 SPOF(sigle point of failure) 가 될 수 있다. 즉 캐시서버도 분산배치해야한다.

- 캐싱을 어느정도로 할 것인가? 캐시 메모리를 과할당하는 것이 좋다.(부족한 것보단 훨씬 낫다는 의미)

- 데이터를 방출할 정책 : 가장 오래된 데이터, 가장 먼저 들어온 데이터, 사용빈도가 가장 낮은 데이터

## CDN(콘텐츠 전송 네트워크)

지금 우리 예제에서 정적 데이터는 웹서버가 그대로 처리하고있다.

사용자가 늘어난다면 이것도 분리해야한다.

CDN은 지리적으로 분산하여 정적 컨텐츠를 따로 보관하는 서버를 두는 것이다.

CDN도 캐싱의 일종이다.

사용자가 이미지에 접근하면 CDN서버에 요청하고 없는 데이터라면 원본 서버에 요청해서 가져온다. CDN은 캐싱뒤에 사용자에게 전송한다.

### CDN 사용 시 고려해야 할 사항

- CDN은 나가고 들어오는 데이터의 양에따라 비용이 부과된다.

- 캐싱 만료시점 : 위에서 설명한 캐싱과 같다.

- CDN이 죽었다고 컨텐츠를 주지못하면 안된다. 원본서버로의 우회를 생각해놓아야한다.

- 아직 만료되지않은 데이터를 지워버릴 수 있다.

## 무상태 웹 계층

웹 계층도 수평적으로 확장해야한다.

서버1 서버2 서버3이 각각 사용자의 세션정보를 분산해서 가지고있다면 사용자는 요청해야할 서버가 정해지고 해당 서버가 죽으면 요청이 불가능하다.

이렇게 종속적인 설계는 좋지않다. **이를 상태 의존적 설계라한다.**

무상태 아키텍처는 사용자의 세션정보를 따로 두어 모든 웹서버가 공유하므로 사용자의 요청이 특정한 서버에 들어오지 않아도된다.

## 데이터 센터

지금까지 우리가 도입해온 확장을 정리해보자.

로드밸런서를 도입해 하위에 여러 웹서버를 두었다.

데이터베이스를 다중화해 분산처리와 안정성을 높였다.

캐시를 도입해 데이터베이스를 통하지않고 빠른 성능을 갖추었다.

무상태 아키텍처로 공유서버를 만들어 사용자의 상태정보를 모든 웹서버가 공유한다.

**위의 확장을 한 묶음으로 생각해보자.**

이 묶음 자체를 그대로 복사해 하나 더 만들 수 있다.

**데이터 센터를 두 개 이용하는 것이다.**

데이터 센터 한 곳이 자연재해로 죽는다면 다른 데이터센터로 이동하면된다.

### 기술적 난제 해결사항

- 다른 데이터센터로의 우회는 GeoDNS를 통해 가까운 데이터센터로 트래픽을 보낼 수 있다. GeoDNS는 지리적으로 분산된 DNS서버이다.(위치 기반으로 이동해야할 IP주소를 동적으로 결정)

- 서로 다른 데이터베이스를 이용하고있다면 우회하더라도 찾는 데이터가 없을 수 있다. 이때 데이터센터끼리도 다중화를 고려해야한다. (Netflix)

## 메세지 큐

메세지 큐는 작업을 저장하는 버퍼라고 생각하자.

구조는 생산자가 메세지를 만들어 발행하고 소비자가 이것을 소비한다.

중요한 점이 몇 가지 있다.

- **비동기 처리** : 즉각적으로 처리하지 않아도 된다. 주로 시간이 오래 걸리는 작업들을 메세지 큐로 구현한다.

- **서비스와 서버간 결합이 느슨**해진다. 생산자는 소비자 프로세스가 죽어도(작업을 처리할 소비자) 큐에 넣을 수 있고 소비자는 생산자가 가용상태가 아니어도 메세지를 수신가능하다.

## 데이터베이스의 규모 확장

앞서 설명했지만 큰 서비스에선 수평적 확장이 옳다.

수평적 확장은 **샤딩**이라고도 부른다.(구글이 사용중)

**샤딩**은 큰 데이터베이스를 **샤드**라는 작은 단위로 분할한다.

샤딩은 해쉬맵처럼 작동한다.

키를 가지고있고 키를 이용해 탐색하고 저장한다. 당연히 중요한것은 **해시함수**를 이용해 데이터를 고르게 분산하는 것이다. (샤드에 보관되는 데이터는 중복이 없다.)

### 주의점

- 재 샤딩 : 하나의 샤드로는 더 이상 감당불가능할때, 샤드간 데이터분포가 고르지 못할때 해시함수를 변경하고 재 샤딩해야한다.

- 자주 찾는 데이터는 분산해야한다.

- 조인이 불가능하다 (서버를 쪼개기때문) 해결법은 DB를 비정규화하는 것이다.(하나의 DB에서 모든 질의를 담당)