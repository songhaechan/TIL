구글 드라이브 설계
=

## 개략적 설계

이번 장에서는 앞의 주제들을 되새길겸 한 대의 서버에서 시작한다.

아래 구성을 모두 한대로 처리한다.

- 파일을 업로드하고 다운로드할 웹서버
  
- 메타데이터를 저장할 데이터베이스(사용자정보,파일정보 등)
-  파일을 저장할 저장소 시스템

파일 업로드, 다운로드, 히스토리 갱신 api가 제공된다.

이 모든 통신에는 HTTPS를 사용한다(SSL을 이용한 보안프로토콜)

### 저장공간의 부족

충분하지않은 파일저장소 용량은 심각한 문제다.

재빠르게 샤딩을 이용해 키값을 분산하고 데이터를 분산하면 해결이 가능하다.

하지만 외부서비스 중 매우 탁원한 확장성 가용성 보안성을 지닌 S3가 존재한다.

지역내에서 다중화, 다른 지역끼리의 다중화도 지원한다.

### 로드밸런서와 데이터베이스계층의 분리

1장에서 그랬듯이 로드밸런서를 도입해 웹서버의 확장과 제거가 용이하도록하고 대규모 트래픽을 감당할 수 있게된다.

데이터베이스 또한 한 서버에서 분리해 다중화와 규모 확장을 용이하게한다.

### 동기화 충돌

같은 파일을 두 사용자가 동시에 접근해 수정한다면 조금이라도 먼저 수정한 사용자의 버전과 (저장소상 최신버전) 후에 수정한 사용자의 버전을 비교하고 두 파일을 합칠지 대체할지를 결정하도록한다.

### 개략적 설계안

**블록 저장소 서버 도입**

파일은 한꺼번에 업로드하지않고 작은 블록단위(4MB)로 나누어 전송한다.

이 블록들은 고유 해시값을 가진다. 또한 각 블록의 메타데이터는 따로 저장된다.

**아카이빙 저장소**

오랫동안 사용하지않는 파일들은 아카이빙 저장소에 따로 저정한다.(비용이 싸다)

**오프라인 사용자 백업 큐**

사용자가 오프라인이더라도 갱신내용은 큐에 넣고 로그인 시 갱신해줄 큐를 마련한다.

## 상세설계

### 블록 저장소 서버

블록으로 나누는 이유는 아래와같다.

- 델타 동기화

    파일이 수정되면 수정된 블록만 업로드해 동기화한다

- 압축

    블록 단위로 압축하면 저장용량을 크게 줄일 수 있다.

### 업로드

파일 메타데이터 업로드

1. 새 파일의 메타데이터를 추가하는 요청
2. 새 파일이 업로드 대기중으로 상태를 변경
3. 새 파일이 추가됐음을 알림서비스에 통지

파일 업로드

1. 파일을 블록 저장소 서버에 업로드
2. 블록단위로 쪼갠 후 압축,암호화
3. 메타데이터를 업로드 완료 상태로 변경
4. 업로드가 종료됐음을 알림서비스에 통지

### 다운로드

서로 다른 클라이언트가 파일을 변경하면 그 파일의 변경을 감지해야한다.

이는 알림서비스를 통해서 다른 사용자에게 통지하는 방식을 사용한다.

변경된 내용은 변경된 블록만 새롭게 가져와 재구성한다.

### 저장소 공간 절약

- 계정차원에서 중복을 제거한다.(블록의 해시값을 이용해 비교)

- 지능적 백업

    파일 버전 개수에 상한을 둔다. 오래된 버전부터 지운다.

    중요한 버전만 보관

- 아카이빙 저장소 활용

### 장애 처리

- 로드밸런서 장애

    따로 부 로드밸런서를 활성화시켜 트래픽을 이어받아야한다. 로드 밸런서끼린 heartbeat를 주기적으로 보낸다.

- 블록 저장소 서버 장애

    당연히 다른 서버가 이어받아야한다.(규모 확장)

- 클라우드 저장소 장애

    s3에 장애가 발생해도 s3는 다중화가 돼있기때문에 다른 서버에서 혹은 다른 지역에서 가져오면 된다.

- API 서버 장애

    api 서버에 장애가 발생하면 해당 서버는 격리시켜 트래픽을 보내지않는다.

- 캐시 서버 장애

    정답은 다중화다. (앞장의 안정해시설계, 샤딩 등)

