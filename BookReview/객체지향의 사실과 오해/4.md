역할, 책임, 협력
=
## 협력

협력은 네트워크다. 협력은 요청을 보내고 응답을 받음으로써 구성된다.

요청을 보낸다는 의미가 무엇일까?

우리는 스스로 해결할 수 없는 일을 타인에게 특정 행동을 부탁한다.

객체도 마찬가지로 그 스스로가 수행할 수 없는 행동을 다른 객체에게 요청함으로써 협력관계를 생성한다.

연쇄적인 요청과 응답은 이 협력관계를 생성해 하나의 목표에 다가가는 과정인 것이다.

## 책임

어떤 객체가 어떤 요청에 응답해 줄 수 있거나 적절한 행동을 할 의무가 있는 경우 책임을 가진다고 말한다.

책임에는 두가지 분류가 있다.

- 하는 것 (doing)

    - 다른 객체의 행동을 시작시키는 것
    - 다른 객체의 활동을 제어하고 조절하는 것
    - 객체를 생성하거나 계산을 하는 등의 스스로 하는 것

- 아는 것 (knowing)

    - 개인적인 정보에 관해 아는 것
    - 관련된 객체에 관해 아는 것
    - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것

동화 이야기를 잠시 해보자.

어떤 누군가가 왕/여왕에게 재판을 명령한다.

왕/여왕은 토끼에게 증인을 불러올 것을 요청한다.

토끼는 증인을 재판대에 세운다.

왕/여왕은 증언을 명령한다.

여기서 토끼는 증인이 누구인지 구체적인 객체를 알고있으며, 증인을 입장하도록 행동을 시작시킬 수 있다. (아는 것과 하는 것)

왕과 여왕은 토끼에게 증인을 요청하고 증인에게 증언을 요청한다. 다른 객체의 행동을 제어하는 것이다.(하는 것)

증인은 자신이 알고있는 것을 진술한다. (아는 것과 하는 것)

이 협력관계에서도 객체지향에서 보이는 캡슐화가 아주 잘 드러나있다.

왕과 여왕은 구체적인 증인은 알지 못하지만 여러 증인을 추상화하고 구체적인 증인에대해선 알지 못한다. 그리고 다른 객체의 행동을 알지못하지만 **메세지를 보냄으로써** 협력을 요청할 수 있다.

메세지는 협력관계에있는 객체들이 서로 주고받는 요청과 응답이다. 메세지를 수신한 객체는 적절한 책임을 수행해야한다.

하지만 메세지와 책임은 수준이 같지않다. 보통 하나의 책임을 수행하기위해 여러 메세지를 사용해야한다.

## 역할

개인적으로 이 역할이 객체지향을 이해하고 활용하는데에 필수적이라고 생각한다.

위 예시를 다시 보자.

왕, 토끼, 모자장수(증인)은 구체적인 객체로 표현된다.

하지만 그들이 하는 역할을 생각해본다면 판사, 토끼, 증인 으로 생각할 수 있다.

즉 판사는 판사의 책임을 가질 수 있는 객체라면 어떤 객체라도 **대체될 수 있음**을 의미한다.

증인도 마찬가지다 증인의 책임을 수행할 수 있다면 그 누구도 증인이 될 수 있다.

앞서 계속 강조해오지만 역할은 대체될 수 있음을 의미한다.

대체가 가능하다는 것은 앞장에서 말한 추상화가 가능하다는 것이다.

모자장수, 요리사, 앨리스는 다 다른 객체지만 증언할 수 있는 책임이 있기때문에 모두 증인이라는 카테고리로 묶을 수 있고 이들을 추상화할 수 있다.

역할을 생각할 수 있다는 것은 다시말하면 협력을 추상화할 수 있다는 것이다.

## 협력의 추상화

구체적인 객체들로 협력관계를 구성하면 협력에 참여하는 객체가 늘어날때마다 협력관계는 그만큼 많아진다.

같은 협력관계임에도 불구하고 객체가 다르다는 이유로 불필요하게 생성되는 협력관계는 추상화해야한다.

역할을 생각한다면 협력은 추상화가 가능하다.

그리고 추상화된 협력관계는 재사용이 가능하다.

## 흔한 오류

### 첫 번째
객체는 데이터를 저장하는 클래스에 불과한가?

아니다. 객체는 데이터를 포함하기는 하지만 객체의 본질은 협력관계속에 있는 행동 즉 책임이다.

객체를 데이터를 담는 그릇이라고 생각하는 순간 객체지향적 설계는 데이터중심적 설계로 변질된다.

물론 단순하게 데이터만 담는 클래스가 존재한다. 하지만 그 클래스는 객체가 아니다. 그래서 클래스와 객체를 분리해서 생각해야하는 것이다. 객체지향 언어에서 클래스를 통해 객체를 생성하기때문에 클래스와 객체가 같다고 생각하지만 모든 클래스가 객체가 될 순 없다.

### 두 번째

클래스와 클래스 간의 관계를 표현하는 정적인 측면이 중요한가?

물론 구체적인 관계를 볼 수 있다는 점에서는 그다지 나쁜것 같지는 않다.

하지만 객체지향은 협력속에 있는 객체들의 행동과 책임을 중심으로 봐야한다.

런타임시에 결정되는 동적인 객체들의 관계로 생각해야한다.

동적인 관계는 추상화(자바에서 인터페이스, 추상클래스)와 밀접한 관련이 있다. 

런타임 이전에는 어떤 객체가 협력속에서 책임을 수행할 지 알 수 없다.

사용자가 정하는 관계이기때문에 객체의 협력은 항상 동적으로 결정된다는 사실을 명심하자.

## 협력부터 생각하라

어떻게 설계하는 것이 좋을까?

무슨 나무를 심을지부터 생각하지말고 어떤 숲을 만들지를 생각해야한다.

물론 소프트웨어 전반의 모든 구조를 단번에 협력관계를 그릴 수는 없다.

하지만 협력을 생각한다는 것은 다른 말로 객체의 책임을 생각한다는 것이고, 동시에 어떤 역할일지를 고민하는 것이다.

책임(행동)과 역할을 나누면 그만큼 협력관계가 좀 더 쉽게 생성될 수 있다.

그렇기때문에 협력을 우선으로 생각하고 그 후 책임을 생각하면 객체의 상태(데이터)는 자연스럽게 따라온다.



