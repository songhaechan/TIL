어댑터 패턴
==
어댑터 패턴에대한 대표적인 예시로 SLF4J가 있다.

SLF4J는 로깅 API를 제공하도록하는 Logger인터페이스를 제공한다.

지금 작성하는 대부분의 코드는 System.out.println으로 콘솔에 출력하지만 실무에서는 로그수집을 위해서 DB나 파일에 로그정보를 수집한다.

그러기위해선 단순히 화면에 출력하기보단 다양한 로그정보(데이터의 크기, 트레픽양 등)를 기록해야한다.

여기서 다양한 로깅라이브러리를 사용한다. logback, log4j, 자바의 logging 등이 있는데 이들 모두 각자의 로그를 제공하는 방식이 추상클래스 또는 인터페이스이다.

SLF4J는 로깅 라이브러리들을 연결해주는 역할을 하는 것이다.

SLF4J가 없다고 가정해보자.

최초에 개발자는 log4j를 통해 로깅시스템을 구현했다. 그런데 logback을 이용한 로깅시스템으로 바꿔야한다면 로깅시스템자체를 뒤집어 엎어야한다.

SOLID의 의존역전원칙, 개방폐쇄원칙이 사용되야하는 아주 적절한 예시이며 이 경우 어댑터 패턴을 이용해 SLF4J를 개발했다.

SLF4J는 Logger라는 인터페이스를 제공한다. 그리고 Logger를 구현한 각각의 로깅라이브러리에대한 **"어댑터클래스"**가 존재한다.

이 어댑터클래스는 상속을 이용해 직접 log4j나 logback의 메서드를 호출해 사용할 수도 있고, 객체를 직접 조립해서 사용할 수도 있다.

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class MyClass {
    private static final Logger LOGGER = LoggerFactory.getLogger(MyClass.class);

    public void myMethod() {
        LOGGER.debug("This is a debug message");
        LOGGER.info("This is an info message");
        LOGGER.warn("This is a warning message");
        LOGGER.error("This is an error message");
    }
}
```

위 클래스는 SLF4J를 이용한 예시다. LoggerFactory를 통해 팩터리메서드 방식으로 객체를 생성한다.

```java
implementation 'ch.qos.logback:logback-classic:1.2.6'
```

위와 같이 logback에대한 의존관계를 설정했다면 SLF4J는 logback에대한 어댑터클래스를 이용해 로깅API를 실행한다.

**그런데 만약 logback에서 log4j로 교체해야한다면 어떻게 될까?**

SLF4J가 제공한 추상화 덕분에 의존관계만 다시 설정한다면 LOGGER.메서드들은 수정할 필요없이 콘크리트클래스만 교체할 수 있다.

이런 구현이 가능한 이유의 핵심은 어댑터 클래스다.

아래는 log4j어댑터 클래스다.

```java
public final class Log4jLoggerAdapter extends MarkerIgnoringBase implements LocationAwareLogger {
    
    final transient Logger logger;

    static final String FQCN = Log4jLoggerAdapter.class.getName();

    Log4jLoggerAdapter(Logger logger) {
        this.logger = logger;
    }

    public boolean isTraceEnabled() {
        return logger.isTraceEnabled();
    }

    public void trace(String msg) {
        logger.log(FQCN, Level.TRACE, msg, null);
    }

    public void trace(String format, Object arg) {
        if (logger.isTraceEnabled()) {
            FormattingTuple ft = MessageFormatter.format(format, arg);
            logger.log(FQCN, Level.TRACE, ft.getMessage(), ft.getThrowable());
        }
    }

    // 생략
}
```
이 클래스는 SLF4J의 Logger인터페이스를 상속받은 LocationAwareLogger 인터페이스를 구현한 어댑터 클래스다.

클라이언트가 어떤 로그API를 사용하는지 상관하지않고 어댑터는 그저 log4j객체에 맞게 변환해주는 작업만 수행한다.

logback이라면 logback에 맞게 변환해준다.

그렇기때문에 클라이언트는 객체의 의존관계변경만으로도 로깅시스템을 쉽게 변경할 수 있다.

이런 변환과정들때문에 Adapter라는 이름이 붙여졌다.

110V충전기를 220V환경에서 쓰고싶을 때 어댑터만 바꿔주면 사용할 수 있듯이 로깅시스템을 변경하고싶다면 의존관계만 바꿔주면된다.


옵저버 패턴
==

옵저버 패턴은 크게 주제객체, 옵저버객체 두가지로 분류된다.

주제객체는 두 가지 책임을 가진다. 

1. 옵저버의 목록을 가지고있으며 옵저버를 추가/삭제한다.

2. 상태의 변경을 옵저버에 알린다.

한 가지 상황을 가정해보자. 비정상 상태 발생 시 관리자에게 상태를 알리는 메일을 보내야한다.

그런데 역시나... SMS로도 보내달라는 새로운 요구가 발생한다면 기존에 코드를 수정해야한다.

이렇게 정해지지않은 임의의객체에게 상태를 통지할 때 사용하는 것이 옵저버패턴이다.

여기서 SMS에 통지하는 객체, 메일로 통지하는 객체는 옵저버객체가된다.

이 옵저버는 하나의 인터페이스를 구현한다.

주제객체는 이 옵저버객체를 인터페이스타입으로 List에 저장한다. 즉 새로운 요구사항이 발생한다면 옵저버 인터페이스를 구현하는 객체를 생성하고 주제객체에 추가하면된다.

```java
public class StatusSubject {
    private List<StatusObserver> observers = new ArrayList<>();

    public void add(StatusObserver observer){
        observers.add(observer);
    }

    public void remove(StatusObserver observer){
        observers.remove(observer);
    }

    public void notifyStatus(Status status){
        for(StatusObserver observer : observers){
            observer.onAbnormalStatus(status);
        }
    }
}
```

위 코드는 주제객체를 구현했는데 StatusObserver 타입을 List에 add remove하는 것을 볼 수 있다.

비정상 상태는 for문을 돌며 옵저버구체클래스가 구현한 onAbnormalStatus메서드를 호출하여 status객체를 전달한다.

**디자인패턴을 배우며 항상 느끼지만 중요한 것은 SOLID원칙이다. 변경되는 부분은 인터페이스로 추상화했기때문에 위 notifyStatus같은 아름다운 메서드가 탄생할 수 있는 것이다.**

사실 주제객체 또한 SOLID원칙의 단일책임원칙으로 해석할 수 있다. 애초에 요구사항이 **임의의 모든객체** 이기에 모든 객체를 다뤄야함으로 List를 이용하고 for문을 이용해 status를 전달한다.

이 주제클래스를 책임을 따로 분리해논것에 불과하다.

```java
public class StatusChecker extends StatusSubject{

    public void check(){
        Status status = loadStatus();

        if(status.isNotNormal()) {
            super.notifyStatus(status);
        }
    }

    private Status loadStatus(){
        Status status = new Status();
        return status;
    }
}
```
이 클래스는 위에 언급한 주제객체를 상속받아 메서드를 호출하고있다. 클라이언트 클래스라 봐도 되겠다.

옵저버 객체를 추가하기만한다면 주제객체나 주제객체를 상속받은 위 객체는 전혀 건드릴 일이 없다.

옵저버 패턴 구현시 고려사항
--
1. 옵저버에게 상태를 알려주는 시점을 누구에게 맡길 것인가.

위 예시는 StatusChecker 클래스가 옵저버에게 상태를 전달한다. 하지만 때로는 StatusChecker클래스를 관리하는 또 다른 클래스에서 옵저버에게 상태를 전달 할 수 있다.

예를들어 2번의 비정상 상태가 발생할때만 통지하기로한다면 StatusChecker에서 직접 상태를 전달해서는 안된다. 즉 StatusChecker를 관리하는 또 다른 클래스가 통지해야한다.

2. 옵저버 인터페이스 개수에 관해

위에선 상태변경이 메일이든 SMS든 같은 메서드를 이용한다.

하지만 클릭 이벤트, 드레그 이벤트 등 서로의 메서드가 다른 기능을 가진다면 그만큼 인터페이스에 구현해야하는 메서드가 늘어나는데 이 때 클릭 이벤트는 드레그 이벤트의 메서드가 필요하지않기때문에 불필요한 코드가 늘어난다 ( 빈구현을 해주어야한다.)

3. 주제 객체의 상태에 결함이 없어야한다.

```java
public class AnySubject extends SomeSubject{
    @Override
    public void chageState(int newValue){
        super.chageState(newValue);
        if(isStateSome()){
            state += newValue;
        }
    }
}
```

위 코드는 주제객체인데 위 코드는 결함이 존재한다. 조건문이 아래 있기때문에 changeState메서드 호출 후에 조건문이 실행된다.

사실 조건문과 changeState()의 순서를 바꿔주면 문제가되지않겠지만 책에서 굳이 템플릿 메서드 패턴을 해결책으로 제시한 이유는 안전성으로 생각된다.

애초에 구조화된 형태로 틀을 제공하고 세부구현만 강제하게되면 저런 문제가 생길일이 없기때문이다.

4. 옵저버 구체 클래스의 실행시간에 대하여

만약 구체 클래스가 10개이고 수행시간이 10분이라면 100분이 소요될 것이다. 심지어 마지막 클래스는 90분을 기다려야한다.

이 때는 일정시간 이상 걸리는 작업이라면 별도 쓰레드로 실행하는 등의 기준이 필요하다.

----

미디에이터 패턴
=

![img](/BookReview/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EA%B3%BC%20%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/IMG_1979.jpg)

위 사진과 같이 프로그램을 개발하려한다.

동작방식은 매우 간단하고 유튜브를 연상하해보자.

영상을 선택하면 제목과 영상이 표시될 것이고, 영상 제어를 통해 다음 영상 이전 영상을 선택할 수 있다.

영상제어를 통해 앞으로 뒤로 감기가 가능하다.

이때 클래스의 관계는 어떨까?

![img](/BookReview/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EA%B3%BC%20%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/IMG_1980.jpg)

클래스의 의존관계가 너무 직접적으로 설계되어있어 불편한 느낌이 있다.

**직접적인 의존관계는 확장을 어렵게 만들고 수정의 증가를 불러온다.**
--

아니나 다를까 요구사항이 증가했다.

영상에대한 추천목록과 자막을 추가해달라는 것이다.

이를 반영하면 아래와 같다.

![img](/BookReview/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EA%B3%BC%20%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/IMG_1982.jpg)

더욱 걱정스러운 관계다. 하나의 예시를 들어보자.

MediaCotroller는 Video를 의존하고있고 Video는 CaptionUI를 의존하고 있다.

CaptionUI의 변경이 VideoPlayer에 영향을 주고 이 영향은 또 다른 클래스에게 미칠 수 있다.

단일구조가 되어버린 것이다.

단일구조는 재사용을 매우 어렵게한다.

VideoPlayer만 원하는 객체는 필요하지도않은 CaptionUI나 MediaController까지 구현해야하는 것이다.

이제 미디에이터 패턴을 이용해 개선해보자.

![img](/BookReview/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EA%B3%BC%20%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/IMG_1981.jpg)

첫 번째 장점으로 Mediator를 중심으로 서로의 객체들은 직접적인 의존관계를 갖고있지않게된다.

하나의 흐름을 예시로 들어보자.

사용자가 비디오목록에서 다음 비디오를 선택했다.


    VideoPlayer : Mediator야 나 다음 영상 필요해

    Mediator : OK VideoListUI에서 얻어올게

    VideoListUI : OK Mediator한테 정보 넘겨줄게 

    Mediator : OK 정보받았다.

    VideoPlayer : Thank You !

Mediator의 역할이 보이는가? 

클래스들 사이에서 중계자 역할을 하고있는 셈이다. 다른 클래스의 기능을 사용하기위해 직접적으로 객체를 생성하지않고 중계자에게 물어보는 방식으로 한 단계를 더 거친다.

그리고 또 한가지 VideoPlayer는 Mediator를 의존하지 않는다.

기존에 VideoPlayer가 다른 클래스를 직접의존하기때문에 재사용이 어려웠지만 이제 VideoPlayer는 어떤 클래스에도 의존하고있지않기때문에 재사용성이 높아진다.

하지만 주목해야할 점이 하나있다.
-

모든 이점은 Mediator의 도입으로 시작되었지만 문제의 시작이 Mediator가 될 수도 있다는 것을 알아야한다.

위 클래스 도식에서 Mediator의 책임은 매우 크다.

많은 요청을 받아서 알맞은 객체에게 실행을 위임해야하기때문에 더 많은 기능이 추가된다면 그에따라 의존관계도 늘어날 것이다.

추상 미디에이터 클래스
--

기존에 미디에이터클래스는 일반 클래스였지만 추상 미디에이터 클래스를 도입함으로써 미디에이터 클래스의 재사용성을 높일 수 있다.

무슨 말인가하면 만약 VideoPlayer가 아닌 MP3Player를 위한 미디에이터 클래스가 필요하다면 미디에이터자체를 추상화하고 비디오미디에이터 MP3미디에이터를 따로 구현하는 것이다.

---

파사드패턴
==













