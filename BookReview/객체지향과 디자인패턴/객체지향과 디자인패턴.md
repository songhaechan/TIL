객체지향과 디자인패턴
===

들어가기
---
----
**객체지향언어를 사용해서 프로그램을 작성한다고해서 객체지향적인 프로그램이되는것은 아니다.**

Java와 같은 언어를 사용하면서도 충분히 절차지향적인 프로그램을 작성하게될 수도 있다. 이번 장에서 다루는 핵심은 객체지향언어를 사용하면서도 객체지향적인 성격을 전혀 띄고있지않는 예시를 보여준다.

지저분해지는 코드를 보자.

서비스요구사항은 간단하게 사용자가 메뉴1, 메뉴2를 눌렀을 때 해당화면을 출력해준다. 그리고 버튼1을 누르면 메뉴1과 메뉴2에 따라 각각 해당하는 화면을 출력한다.

```java
    if(menu == 1){
        print(화면1)
    }else if(menu == 2){
        print(화면1)
    }else if(butoon == 1){
        if(menu == null){
            return;
        }else if(menu == 1){
            print(메뉴1에대한 버튼1의 화면)
        }else if(menu ==2){
            print(메뉴2에대한 버튼1의 화면)
        }
    }
```
요구사항은 위의 유사코드와 같이 설계될것이다.

메뉴는 2개 뿐이고 버튼은 1개뿐이다. 이 상황에선 문제의식을 느끼기어렵지만, 서비스 요구사항이라는것은 항상 변화한다.

사용자가 메뉴를 추가해달라는 요청이들어왔다. 개발자는 요구사항 수정을 위해 else if문을 하나 추가해 menu 3 에대한 화면을 출력해주고 button 1이 입력되었을 때에도 else if문을 추가해 처리할 것이다.

아직까지도 사용자의 요구사항은 쉽게 수정될 수 있다.

그런데 안타깝게도(?) 서비스가 유명해져 더 많은 요구사항이 들어온다. 메뉴는 10개를 추가하고 버튼도 10개를 더 추가해달라고한다.

메뉴에대한 분기분은 더 늘어날 것이고 button마다 분기문도 기하급수적으로 늘어날것이다.

점점 개발자는 코드를 어디에 추가해야할지 찾는 시간이 길어질 것이고 누락하는 경우도 발생할 것이다.

한마디로 굉장히 지저분한 코드가 된다.

---

이제 위 코드를 객체지향적으로 설계해보자

서비스 요구사항중에서 중복되는 코드들이 존재한다. 메뉴를 선택하면 메뉴의 종류에 관계없이 해당하는 화면을 출력해주고 버튼은 메뉴의 종류에따라 다른 화면을 출력해줘야한다는 공통점이 있다.

```java
    interface ScreenUI{
        printScreen()
        Button1Clicked();
    }

    class Menu1UI implments ScreenUI{
        printfScreen(메뉴1)
        Button1Clicked(메뉴 1에대한 화면)
    }

    class Menu2UI implments ScreenUI{
        printfScreen(메뉴2)
        Button1Clicked(메뉴 2에대한 화면)
    }

    class main(){
        private ScrennUI currentScreen = null

        if(menu == 1){
            currentScreen = new Menu1UI
            currentScreen.printfScreen()
        }else if( menu == 2){
            currentScreen = new Menu2UI
            currentScreen.printfScreen()
        }else if(button == 1){
            currentScreen.Button1Clicked()
        }
    }
```

공통적인 부분을 interface로 구현하여 객체가 이를 구현하도록 강제하였다. 

처음엔 겉으로보면 지저분해지는 코드보다 구조는 더 복잡해졌다. 그런데 객체지향의 묘미는 요구사항이 증가될 때 빛을 발한다.

우선 인터페이스타입으로 객체를 생성하게되면서 currentScreen변수 하나로 Button1에대한 제어도 쉬워졌다. Button2가 생성되더라도 인터페이스에 메서드를 추가해주고 else if문을 하나만 추가해주면 된다. 메뉴가 추가되면 메뉴에대한 클래스를 생성하고 ScreenUI를 구현해주면 간단하게 끝난다.

메뉴가 100개이고 버튼이 1개인 경우에 버튼에대한 if문속에 100가지 메뉴에대한 if문이 추가되어야했지만 이젠 하나의 문장으로 제어가된다.

이처럼 소프트웨어는 변화하는 요구사항에 맞게 변화할 수 있어야한다. 새로운 요구사항을 즉각적으로 반영하기위해선 객체지향적인 설계로 유지보수가 쉽게해야한다.

---

절차 지향과 객체 지향
---

**절차 지향적**으로 설계한다는 것은 그저 프로그램이 한줄 한줄 절차에따라 실행된다는 의미를 넘어서서 **데이터를 중심으로 프로시저(절차,함수)가 구성**된다는 것을 의미한다.

데이터를 중심으로 프로시저를 구성하게되면 데이터 타입이나 의미를 변경해야할 때 수정해야하는 프로시저가 증가하게된다.

배열타입의 데이터를 두고 다수의 프로시저가 구현되어있을 때를 생각해보자. 갑자기 서비스 요구사항이 변경되어 배열타입이 아닌 열거타입으로 변경해야한다면 배열타입으로 프로시저를 구성하는 모든 프로시저를 수정해야만한다.

즉 하나의 변경사항이 수 많은 변경사항을 불러일으키게된다.

**객체지향**은 프로시저를 실행함에 있어 필요한 만큼의 데이터를 가진다. 이렇게 조각조각의 단위를 객체라고하며 객체는 **서로의 데이터에 접근하는것이 아니라 객체가 제공하는 기능을 사용하는 것**이다. 

객체 A의 데이터타입이 변경되었다하더라도 객체 B는 객체 A가 제공하는 **기능**을 사용하기때문에 영향을 받지않는다.

객체의 핵심은 **기능**을 제공하는 것이지 객체내부에서 어떤 데이터를 다루는지는 (다른 객체 입장에서)중요하지않다.

객체가 제공하는 기능을 오퍼레이션이라고 부르고 그 **오퍼레이션**을 사용하려면 사용법을 알아야하는데 그것을 **시그니처(이름, 파라미터, 결과 값)** 라고 부른다. 오퍼레이션의 집합을 객체의 인터페이스(자바의 인터페이스와 다름)라고 부른다. 그리고 객체가 다른 객체에게 오퍼레이션을 요청하는것을 **메시지를 보낸다**고 표현한다.

---

객체의 책임과 크기
---
다시 말하지만 객체는 객체가 제공하는 기능으로 정의된다. 책에 나온 예시를 살펴보자

    파일 읽기 객체 : 파일에서 데이터를 읽어와 제공
    암호화 처리 객체 : 데이터를 암호화해서 다른 파일에 전송
    파일 쓰기 객체 : 파일에 데이터를 쓴다.

각각의 객체는 책음을 가지고있다. **객체의 책임을 결정하는 것**이 객체 지향 설계의 출발점이다.

블랙잭 프로젝트를 하면서도 느꼈지만, 객체의 책임을 처음부터 정확하게 규정하고 프로그래밍하기란 쉽지않다.

우선은 기능을 정리하고 이 기능들을 각 객체에 배분해줘야한다. 여러가지의 경우의 수들이 있고 한 가지의 경우의 수를 선택하더라도 나중에 수정될 수 있다.

객체의 책임소재를 규정하는 방법에대해 책에서 제시하는 한 가지 확실한 규칙이있다.

책에서의 예시를 통해 객체의 책임을 더 잘게 나눠보면

    흐름 제어 객체 : 암호화 요청, 데이터 읽기 요청, 파일 쓰기 요청
    파일 읽기 객체 : 파일에서 데이터를 읽어와 제공
    암호화 처리 객체 : 데이터를 암호화해서 다른 파일에 전송
    파일 쓰기 객체 : 파일에 데이터를 쓴다.

위와 같이 큰 흐름을 제어하는 객체와 각각의 작은 기능을 담당하는 객체로 책임을 나눠 좀 더 객체지향적 설계에 가까워졌다.

**객체가 갖는 책임의 크기는 작으면 작을수록 좋다**
--

왜 객체가 갖는 책임을 작게 만들어야하는걸까?

객체의 책임이 큰 경우를 생각해보자. 바로 모든 데이터와 프로시저들이 한 객체에 모아져있는 경우다.
이 경우 절차지향과 같은 효과를 낸다.

다시말해 한 객체의 책임이 커지면 커질수록 절차지향적 설계로 변질된다.

따라서 객체가 가지는 책임이 작으면 변경에 유연하게 대처할 수 있게된다.

지금까지 설명한 내용은 **객체지향 설계원칙 SOLID의 단일 책임 원칙**에 해당하며 뒤에서 자세히 다뤄보자.

---

의존
---
객체가 다른 객체에 의존한다는 것은 무슨 의미일까.

내가 직접 작성한 코드를 보자.

```java
    public class BlackJackGame {
    CardDeck deck; // 전체 카드 덱
    Player player = new Player();
    Dealer dealer = new Dealer();
    public BlackJackGame() {
        this.deck = new CardDeck();
    }
    }
```
BlackJackGame 클래스는 Player와 Dealer CardDeck 객체를 생성해 사용하고 있다.

이 경우 BlackJackGame 클래스는 Player,Dealer,CardDeck 객체에 의존한다고 볼 수 있다.

    A객체 <---- B객체 <----- C객체

이러한 의존관계일때 C객체의 변화는 B와 A에 영향을 미치게되고 나아가 A객체의 변화는 다시 C객체에 영향을 미치는 순환 의존이 발생할 수 있다.

이러한 문제를 적극적으로 해결하기위해 SOLID의 의존 역전의 원칙이 있다.

---
캡슐화
---
유사코드를 통해 절자치향적 방식으로 설계된 프로그램을 확인해보자.

회원의 서비스 만료날짜에따라 서비스 제공여부를 결정짓는 프로그램이 있다.

```java
    class Member{
        private Date expiryData;
        private boolean male;
        public Date getExpiryDate(){
            return expiryData;
        } 
        public boolean isMale(){
            return male;
        }
    }
```
회원 도메인을 사용하는 다른 객체는 서비스가 확장되어감에따라 증가할 것이다.

다른 객체는 Memeber.getExpiryDate()를 호출해 데이터를 **직접**불러오게된다.

다시한번 반복하자면 객체가 **다른 객체의 데이터를 직접 불러오고있다.**

다른 객체에서 해당 데이터를 어떻게 이용하는지 보자.

```java
    if(member.getExpiryDate() != null && member.getExpiryDate().getDate < System.currentTimeMillis()>){
        //처리
    }
```

해당 코드를 여러 객체에서 각자가 사용하고 있을 것이다(코드의 중복 발생). 이 때 서비스 요구사항이 변경되어 만료날이 30일이 지나지않았다면 서비스를 계속 제공한다는 정책이 수립되어 서비스에 반영된다고 해보자.

위 메서드를 사용하는 모든 객체는 수정되어야한다. 100개의 객체가 사용중이라면 100개의 객체 모두 찾아 수정해야한다.

한 달 뒤에 원래 정책대로 다시 가야한다면...? 끔찍한 결과가 발생한다.

코드의 중복도 중복이지만 이렇게 데이터를 직접 가져오는 프로시저를 작성하게되면 데이터의 변경에 유연한 대처가 어렵다.

심지어 위에선 member.getExpiryDate().getDate 이중으로 객체가 의존하는 상황까지 발생했다.

만료날을 검사하는 프로시저의 책임이 누구에게 있는지를 고민해봐야한다. 당연하게도 member객체에게 이 기능의 책임을 지우면 된다. 그리고 다른 객체는 이 기능을 사용만 하기만하면 새로운 정책변화가 생기면 해당 책임을 가진 객체만 수정하면 될 뿐이다
. 이 과정을 **캡슐화**라 부른다. 내부 구현을 숨기고 객체의 기능만을 사용하게끔하는 방식이다.

책에서 데이터 중심적인 프로그래밍을 고치는데 도움이 되는 두가지 방식을 소개하고있다.

> Tell, Don't Ask

**데이터를 물어보지말고 기능을 실행해달라 말하라.**

데이터를 읽어온다는것은 데이터를 중심으로 메서드를 구현한다는 말이고, 이 말은 절차지향적 코드를 유도한다.

> 데미테르의 법칙

Tell, Don't Ask 규칙을 더 잘 따르게 만들어주는 규칙이다
 
1. 메서드에서 생성한 객체의 메서드만 호출
2. 파라미터로 받은 객체의 메서드만 호출
3. 필드로 참조하는 객체의 메서드만 호출

즉 의존적인 상황을 최대한 만들지 말라는 것이다.

```java
member.getExpiryDate().getDate()
```
위에서 이루어지는 호출은 member객체의 getExpiryDate()를 호출해 Date객체의 getDate메서드를 호출하고있다.

데미테르법칙을 위반했다. 넘겨받은 객체의 또 다른 객체를 참조해 메서드를 호출했기때문이다.

---
객체 지향 설계 과정
---
지금까지 객체란 무엇인지, 책임소재 규정, 의존성, 캡슐화를 알아보았다. 간단하게 정리해보자.

객체는 최소한의 책임을 갖고 기능만을 제공해야한다.

기능은 최대한 캡슐화한다.

객체간의 메시지를 어떻게 주고받을 지 결정한다.

위 과정을 계속해서 반복하며 점차 절차지향적인 설계로 변화되어가야한다.