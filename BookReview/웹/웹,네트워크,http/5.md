TCP
=

## 중요한건 신뢰성

기존 IP는 **서로 연결이 되었는지**, **데이터가 잘 도착했는지**에대해 관심이 없다.

즉 **비연결성** **비신뢰성**이 특징이다.

이런 문제점들을 해결하기위해 TCP(Transmission Control Protocol)이 탄생했다.

## 패킷 유실문제 해결 : 시퀀스 번호(TCP헤더)

데이터는 작은 단위인 패킷을 통해 여러 조각으로 나뉘어 전달된다했다.

IP는 이 패킷들이 잘 도착했는지 확인하지않지만 TCP는 이를 확인한다.

**시퀀스 번호**를 통해 패킷에 번호를 붙이고 받는 쪽은 번호에 해당하는 데이터를 잘 받았다는 답장을 해주어야한다.

돌아오는 답장에 적히지않은 패킷번호가 있다면 데이터를 다시 보냄으로써 유실문제를 해결한다.

## 비연결성의 해결 : 플래그(TCP헤더)

IP는 서로 연결된 상태인지 확인하지않는다. 상대방이 받을 준비가 되지않아도 무작정 데이터를 전송한다.

TCP는 이 문제를 **플래그**를 통해 해결한다.

플래그는 총 6가지가 있지만 눈여겨볼 것은 3가지다.

**ACK**, **SYN**, **FIN**

각 플래그는 0과1로 켜고 끌 수 있다.

이 3가지 플래그와 **3-way handshake**, **4-way handshake**를 이용해 비연결성 문제를 해결한다.

## 3-way handshake

클라이언트가 서버에 데이터를 요청하는 예시로 알아보자.

1. TCP헤더에 SYN헤더를 1로 변경하고 서버에 메세지를 보낸다. (이후에 자신의 상태를 SYN_SENT로 변경)

2. 서버는 TCP헤더에 ACK(요청을 잘 확인했음), SYN(나도 연결하고 싶음) 을 켜고 답장한다.(이후에 자신의 상태를 SYN_RECEIVED로 변경)

3. 클라이언트는 ACK플래그를 보고 상태를 ESTABLISHED로 변경하고 SYN(연결하고 싶음)에 대한 답장으로 ACK 메세지를 전송한다.

4. 서버는 ACK플래그를 보고 상태를 ESTABLISHED로 변경한다.

## 4-way handshake

데이터를 모두 받았고 이제 연결을 끊어야한다.

1. 클라이언트는 FIN플래그(연결종료) 메세지를 보내고 FIN_WAIT으로 상태를 변경

2. 서버는 FIN플래그에대한 답장으로 ACK메세지를 보내고 **미처 보내지 못한 패킷을 마저 보내고 기다린다** (CLOSE_WAIT으로 상태 변경)

3. 서버측에서 연결을 종료할 준비가 완료되면 FIN플래그를 보내고 클라이언트의 ACK메세지를 기다린다.(LAST_ACK으로 상태변경)

4. 클라이언트는 ACK메세지를 전송하고 연결이 끊어진다.

## 흐름제어

서로 데이터를 주고받는데 아직 받은 데이터를 처리도 못했지만 계속해서 데이터가 들어온다면 패킷을 놓치는 경우가 있을 것이다.

IP의 경우가 그렇다.

TCP는 흐름제어를 통해서 해결한다.

## 정지-대기 방식

패킷을 하나 전송하고 ACK가 오기전까진 무작정 기다리는 방식이다.

매우 느리고 요즘 사용하지않는다.

## 슬라이딩 윈도 (TCP헤더)

앞서 설명한 3-way handshake에서 윈도크기라는 헤더의 값을 정한다.

윈도크기는 한번에 받을 수 있는 패킷의 크기이다.

미리 정해진 윈도크기에따라 전송자는 패킷을 전송한다. 기존에 하나씩 보내고 ACK를 기다리지않고 윈도크기만큼 전송하고 ACK를 기다린다.

## 혼잡 제어

흐름제어는 데이터의 양 자체에 초점을 맞췄다면 혼잡제어는 **데이터가 다니는 길**에 초점을 맞춘다.

데이터가 다니는 길이 매우 혼잡해 시간이 오래걸린다면 클라이언트는 서버에게 데이터가 오지않았다는 메세지를 보낸다.

서버는 중복된 데이터를 혼잡 네트워크속으로 또 다시 보내게되고 혼잡도는 더욱 증가한다.

이런 문제를 해결하기위해 **합 증가/곱 감소, 느린시작**이 등장했다.

## 합 증가/곱 감소

합 증가 곱 감소는 **첫 윈도크기를 1로** 지정하고 잘 받았다는 메세지를 받으면 **+1만큼 크기를 키운다**

그리고 네트워크가 혼잡하다고 판단되면 **1/2로** 크기를 줄인다.

## 느린 시작

합 증가/곱 감소와 마찬가지로 **첫 윈도크기는 1로**지정한다.

다만 그 후엔 **2배씩 증가**하다가 혼잡이 감지되면 **극단적으로 윈도크기를 1로 감소시킨다.**

## 더 빠른 UDP

TCP는 헤더의 정보가 많고 신뢰성과 연결성을 지향하기때문에 속도가 느릴 수 밖에 없다.

UDP는 TCP보다 빠른 특성을 가지고있는데 이는 비신뢰성과 비연결성을 지향하기때문이다.

**3-way handshake나 패킷의 흐름을 제어하지않는다.**

응답의 정확성보단 속도가 중요한 실시간 스트리밍서비스에서 사용한다.

Netflix를 예로 들자면 영상에 1-2프레임 유실되는것보단 전체적인 속도가 중요할 경우에 사용한다.



