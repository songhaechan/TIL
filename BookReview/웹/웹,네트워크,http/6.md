HTTP
=

**클라이언트와 서버가 요청과 응답을 주고받는 형식 HTTP**

- 요청 HTTP 메세지

- 응답 HTTP 메세지

## HTTP의 특징

- 상태를 가지지 않는다 (Stateless)

    상태를 가지지 않는다는 것은 클라이언트의 이전 요청을 기억하지 못한다는 것인데, 대표적으로 사용자가 로그인을 하고 페이지를 이동해도 해당 사용자가 로그인한 사용자인지 기억하지 못한다는 것이다.(브라우저의 쿠키나 웹서버의 세션으로 해결가능함)

- 비연결성

    요청이 2번오면 연결과 종료가 2번 이루어진다.

    **요즘 HTTP버전에서는 이를 개선해 연결을 지속한다.**

## HTTP 메세지 구조

### 요청 메세지

- 요청 라인

    HTTP 메서드 (GET,POST,DELETE 등)
    경로(url)
    HTTP 버전

- 헤더

    추가 정보를 제공하는 역할
    굉장히 많은 종류의 헤더가 있다.
    뒤에서 설명

- 빈줄

    헤더와 본문을 구분하기위한 용도

- 본문

    요청에는 본문이 많이 들어가지는 않는다.
    응답본문에는 요청에대한 데이터가 들어간다.

    ex) 회원가입을 할 때 정보를 서버에게 제공하는 역할로 사용된다.

### 응답 메세지

- 요청 라인

    HTTP 버전
    HTTP 상태코드
    상태메세지

- 헤더

    추가 정보를 제공하는 역할
    굉장히 많은 종류의 헤더가 있다.
    뒤에서 설명

- 빈줄

    헤더와 본문을 구분하기위한 용도

- 본문

    응답본문에는 요청에대한 데이터가 들어간다.

## HTTP 메서드

### GET

서버에서 데이터를 단순히 가져온다.

서버의 데이터를 변경시키지 않기때문에 안전성이 있다.

반복되는 요청에도 자원의 상태가 변하지않기때문에 멱등성이 있다.

### HEAD

헤더 정보만 요청한다. 응답메세지가 없다.

GET보다 속도가 빠르기때문에 서버 상태를 미리 확인하는 용도로 사용한다.

안전성 O 멱등성 O

### POST

자원을 생성하는 요청이다. 데이터를 수정하거나 삭제할 때에도 사용하기도한다.

자원을 변경하기때문에 안전성이 없다.

반복되는 요청에 자원이 상태가 달라진다. 100번의 POST 요청은 자원을 100번 생성한다. 즉 멱등성이 없다.

### PUT

자원 전체를 수정한다. 일부만 수정하려하면 나머지는 빈값으로 채워지기때문에 전체를 수정하는 용도로 사용한다.

안전성X 멱등성O 

### PATCH

자원의 일부를 수정한다.

안전성X 멱등성X

PATCH에 멱등성이 없는 이유는 특정 자원에 값을 더해달라는 요청이 들어온다면 계속해서 자원의 상태가 바뀌기 때문이다.

### DELETE

자원을 삭제한다.

안전성 X 멱등성 O

## 헤더
헤더는 헤더만 보고도 응답과 요청이 어떤 정보를 가지고있고 어떻게 처리해야할 지를 알 수 있다.

### 공통 헤더

Date , Cache-Control

메세지의 날짜 기존 데이터를 저장할지 정하는 캐쉬정책

### 요청 헤더

host정보, 유저정보를 담는다.

### 응답 헤더

서버의 정보

### 엔티티 헤더

본문에 대한 정보를 포함한다. 본문의 길이, 타입, 언어 정보를 가진다.

이 외에도 정말 많은 헤더가 있다.

## 상태 코드

- 1xx 

    서버가 첫 번째 요청을 받고 추가로 기다리고있다는 상태를 나타낸다.

    주로 실시간 데이터를 받아야하는 서비스에서 사용한다.

- 2xx

    서버가 요청을 제대로 처리했다는 용도로 사용한다.

    200 OK, 201 Created, 204 No Content(본문없는 성공메세지)

- 3xx

    리다이렉션 완료 응답.

    요청을 완료하기 위해 클라이언트에서 메세지 재전송이 필요하다는 의미

- 4xx

    클라이언트 측 전송 오류

- 5xx

    서버 측 전송오류

## SSL, TLS, HTTPS

HTTP는 기본적으로 암호화를 하지않는다.

요즘 url을 보면 https가 붙은 주소가 많은데 이 주소는 HTTP에서 보안이 향상된 버전임을 나타낸다.

http는 주로 중간에 공격자가 메세지를 가로채 민감한 정보를 그대로 탈취할 수 있는 문제점이 있었다.

이 문제를 SSL/TLS가 해결한다.

### SSL? TLS?

SSL 초기에 2.0 이후 버전은 이름만 바뀐 TLS로 명명되었다.

즉 둘은 버전만 다른 같은 개념이다.

더이상 SSL을 사용하지않지만 익숙하기때문에 아직까지 SSL로 부르고있다.

## 대칭키 공개키로 암호화

### 대칭키 기법

대칭키는 하나의 키로 암호화와 복호화를 둘 다 할 수 있다.

하나의 키로 암호화 복호화가 가능하다보니 절차가 단순하고 빠르다.

하지만 하나의 키를 양쪽이 공유해야하는데 중간에 누군가 가로챌 위험이있다.

### 공개키 기법

가로챌 위험을 제거하기위해 등장한 공개키 기법을 알아보자.

공개키 기법에선 키를 두 가지 사용한다.

공개키와 개인키(비밀키) 두 가지를 이용해 암호화와 복호화를 진행한다.

공개키는 누구에게나 공개되어있는 키이고 개인키는 단 한명만 가질 수 있다.

공개키로 암호화했다면 개인키로만 복호화가 가능하고, 개인키로 암호화했다면 공개키로만 복호화할 수 있다.

서버가 개인키를 갖고 클라이언트에게 공개키를 전달하면 누군가 공개키를 가로채도 클라이언트의 암호화된 데이터는 서버측의 개인키로만 복호화할 수 있기때문에 안전하다.

## SSL 동작 방식

1. 클라이언트는 랜덤한 데이터와 지원 가능한 암호화 방식을 서버에 전달

2. 서버는 클라이언트에게 받은 랜덤데이터와 지원 가능한 암호화 방식 그리고 **인증서**를 전달한다.

3. 클라이언트는 인증서를 검증하는데, CA가 발급한 인증서 목록에 있는지 확인하고 CA에서 발급한 공개키를 가지고 인증서를 복호화한다.(서버가 개인키로 암호화한 인증서) 복호화가 가능하다면 서버의 안전성을 신뢰할 수 있게된다.

공격자가 공개키를 가로채고 서버의 데이터를 복호화한다고해서 문제는 되지않는다. 서버의 신뢰성만 보장하는 데이터이기 때문이다.

4. 클라이언트 주고받은 랜덤 데이터를 가지고 임시키를 만들고 앞서 공유된 공유키로 암호화한 후 서버에 전달한다.

5. 서버는 개인키로 암호화된 키를 복호화하고 서로 같은 키를 가지게된다.

6. 일련의 과정을 거쳐 세션키로 변경하고 서버와 통신한다.

## HTTP/0.9

이 당시 웹은 정보 제공자의 역할만 가졌기때문에 HTTP메서드도 GET밖에 지원하지않았다.

그렇기때문에 헤더정보도 없는 매우 단순한 형태의 HTTP메세지를 가진다.

## HTTP/1.0

이 버전에서 지금 형태와 비슷한 헤더가 생겨났다.

HEAD와 POST 방식이 셩겨나고 상태코드, 전송할 데이터의 종류도 증가했다.(이미지, 영상)

## HTTP/1.1 표준의 등장

### 지속적 연결 상태와 파이프라이닝

1.0버전의 모호한 부분을 개선하고 표준화되지않은 기준들을 표준화하고 **성능을 향상 시켰다**

성능 향상의 주된 기법은 **지속적 연결과 파이프라이닝** 기법이다.

기존에 TCP통신에서 3방향 핸드셰이크를 통해 응답이 도착하면 연결을 끊었지만 지속적 연결 상태 기법을 통해 한 번의 핸드셰이크로 여러 데이터를 주고 받을 수 있게됐다.

또 한 가지 문제점은 하나의 요청에대한 응답이 돌아오지않으면 다음 요청이 불가능했다. 즉 지연이 발생하기 쉬운 것이다.

하지만 **파이프라이닝**기법으로 응답이 전송되기전에 요청을 여러개 보낼 수 있게됐고 더 빠른 통신이 가능해졌다.

## HTTP/2 SPDY기반의 성능 향상

위에서 소개한 기법들로 성능이 어느정도 향상되었지만 문제점은 여전히 존재했다.

### 요청이 들어간 대로 처리되고 하나의 요청에 하나의 응답이라는 구조를 가지고있었다.

즉 1번 요청에대한 응답은 첫 번째로 도착해야하는 것이다.

하지만 **스트림 다중화**를 통해 응답의 순서와 상관없이 여러 메세지를 주고받을 수 있게됐다. 즉 빠르게 줄 수 있는 응답부터 순서에 관계없이 줄 수 있는 것이다.

또한 **서버 푸시**를 통해 클라이언트의 요청 없이도 필요한 리소스를 푸시할 수 있게됐다.

이러한 변화를 불러 올 수 있게 된것은 **바이너리 프레이밍** 덕분이다.

기존에 메세지 구조는 요청라인,헤더,바디가 한 묶음 이였지만 이 묶음을 세분화하고 압축한 뒤에 분리된 프레임을 조립하는 방식으로 소통한다.

## HTTP/3

TCP는 HOLB 문제를 지니고있었다.

HOLB는 데이터 신뢰성을 검증하기 위한 단계이다.

TCP는 무조건 순서대로 데이터를 처리해야해서 데이터가 소실되면 해결하는 동안 다른 데이터를 처리할 수 없었다.

이런 문제를 구글이 **QUIC**으로 해결했다.

QUIC은 UDP위에서 동작하기에 빠른 속도를 보장했고 데이터 검증 기능을 구현해 **신뢰성**까지 보장할 수 있었다.

TCP가 단일 경로로 데이터를 전송해 병목이 발생했지만 QUIC은 멀티플렉싱 기법을 통해 여러 경로로 데이터를 전송한다.