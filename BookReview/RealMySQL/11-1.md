## Limit

```sql
select * from employees limit 0,10;
```

위 쿼는 전체 테이블을 풀스캔하면서 딱 10건이 만족되는 순간 쿼리는 종료되기때문에 쿼리가 상당히 빨리 끝난다.

### group by와 같이 사용

이 경우엔 group by가 끝나기전까진 limit은 실행되지않는다.

그다지 많은 성능향상이 없다.

### distinct와 같이 사용

이 경우는 유니크한 값 10건을 찾을때까지 중복을 제거하고 10건이 조회되면 바로 반환한다.

쿼리 성능이 빨라질 수 있는 조건이다.

### where와 ORDER BY와 같이 사용

where 조건이 다 완료되고 정렬을 수행하다 10건이 충족되면 바로 반환한다.

where 조건에 해당하는 레코드가 많다면 전부 조회하고 정렬해야하기때문에 그다지 성능이 빠르진않다.

## limit과 페이징처리

보통 페이징처리는 limit 0 ,10 와 같이 작성한다.

자주 조회되는 쿼리가 첫 페이지이기때문에 성능에 영향이 없지만 뒷쪽 데이터들은 다르다.

limit 2000000, 10; 같은 경우 2000000 레코드를 다 찾고 그다음 10건을 반환하기때문에 성능이 저하된다.

해결법은 3부분으로 나누어 쿼리를 처리한다.

> 자세한 내용은 책에... 첫 페이지용 마지막 페이지용 중간용 으로 나누어 where 조건을 삽입한다.

## COUNT()

대략적인 정보만 필요하다면 테이블 통계정보를 이용하는 것도 좋은 방법이다.

COUNT(*)가 **큰 테이블**에서 실행되면 모든 데이터나 인덱스를 읽어야하기때문에 주의해야한다.

테이블 통계정보를 ANALYZE TABLE 로 통계정보를 자주 갱신해서 사용해야한다는 단점은 있다...

## JOIN의 순서

조인의 순서는 성능에 막대한 영향을 미친다.

인덱스와 함께 알아보자.

### 두 컬럼 모두 인덱스가 있는 경우

옵티마이저가 최적의 선택을 한다.( 별로 신경쓰지 않아도 됨)

### 한 쪽에만 인덱스가 있는 경우

인덱스가 있는 테이블은 드리븐으로 없는 테이블을 드라이빙으로 선정한다.

> 인덱스가 없는 테이블이 드리븐 테이블이되면 드라이빙에서 조회된 행만큼 테이블 풀스캔이 일어나기때문에 비효율적이다.

### 양쪽에 없는 경우

레코드 건수가 적은 테이블을 드라이빙테이블로 선정한다.

해시 조인으로 처리된다.(블록 네스티드는 사용하지않는다.)

## OUTER JOIN

OUTER JOIN의 핵심은 조인되는 테이블을 드라이빙테이블로 선정할 수 없다는 점이다.

이것이 왜 문제냐...

INNER JOIN의 경우 여러 조건들(인덱스 여부, 테이블의 크기 등)으로 조인되는 테이블도 드라이빙테이블이 될 수 있다.

하지만 아우터 조인은 테이블 풀 스캔이 가능한 테이블만 드라이빙테이블이 된다.

즉 성능 저하가 심하다.

웬만하면 이너조인을 선택해야한다.

다시한번 언급하자면 최적화가 불가능하다.

### 자주하는 실수

아우터조인을 수행하고 where문을 적어주면 이너조인으로 실행된다.

정말 아우터 조인이 필요한 경우라면 예상과 다른 경우를 반환받는다.

주의하자.

> where을 제거하고 조인문 조건에 AND로 연결하면 그대로 아우터 조인이 실행된다.

## 지연된 조인

일반적으로 group by와 order by와 조인이 함께사용되면 조인된 후 group by와 order by가 실행된다.

조인이 1200번 발생하고 그루핑, 정렬하는 쿼리와 먼저 그루핑하고 정렬한 후 조인하는 쿼리는 성능이 차이가 3-4배가량 발생한다.

지연된 조인은 from 절에 서브쿼리를 작성해(임시테이블에 저장) 미리 그루핑과 정렬 후 조인하기때문에 조인 횟수가 현저히 줄어든다.

> 지금 페이징 쿼리를 개선해보자.

## 래터럴 조인

원래는 그룹별로 몇 건씩 가져오는 쿼리는 불가능했다.

래터럴 조인은 이를 가능하게해준다.

서브쿼리가 외부 쿼리의 다른 컬럼을 참조할 수 있다는 것이다.

> 외부쿼리의 결과 레코드 단위로 임시테이블이 생기기때문에 꼭 필요한 경우만 사용하자

## 정렬 흐트러짐

해시 조인의 경우 정렬은 이루어지지않는다.

정렬이 필요하다면 꼭 order by를 포함시켜주는 것이 좋다.

## ORDER BY

보통 인덱스를 사용한 order by는 인덱스 순서대로 레코드를 가져온다.

정렬한 것이 아니라 이미 정렬된 결과를 그대로 가져온다.

인덱스를 사용하지못해도 프라이머리키 순서로 가져온다.

임시테이블을 거치게되면 순서는 예측하기 어렵다.

즉 정렬이 필요하다면 위와같이 꼭 order by를 포함시키자.

## 서브쿼리

### SELECT에 쓰인 서브쿼리

임시테이블 x , 비효율적인 쿼리 x

그다지 주의할 사항은 없다.

당연하지만 무조건 이 경우 서브쿼리는 1개의 레코드 1개의 컬럼만 반환해야한다.

### FROM에 쓰인 서브쿼리

버전이 업데이트되면서 서브쿼리를 외부쿼리로 병합하는 최적화를 진행한다.

> 자세한건 1권

### WHERE에 쓰인 서브쿼리

원래는 테이블 풀스캔을 하면서 WHERE 조건문과 일치하는지 하나하나 비교했다.

하지만 최적화 이후에 WHERE조건의 서브쿼리를 먼저 실행해 상수화하는 방식으로 변경됐다.

하지만! 

WHERE (a,b) 튜플 검색은 아직 성능이 좋지못하니(테이블 풀스캔) 사용하지말자.

### WHERE IN 서브쿼리

원래는 테이블 풀 스캔을 실행했지만 최적화 이후엔 조인 최적화를 통해 여러 전략을 사용한다.

> 5가지 전략에대해 1권에 정리 (엄청 어려움 주의)

## CTE

CTE는 이름이 있는 임시테이블이다.

재귀적 CTE, 비재귀적 CTE가 있다.

### 비 재귀적 CTE

CTE는 이름이 있기때문에 재사용이 가능하다.

CTE끼리의 참조도 가능하며 from 절에 직접 서브쿼리를 작성하고 만약 서브쿼리가 중복된다면 임시테이블도 중복되지만

CTE를 사용하면 중복을 제거할 수 있다.

또한 선언을 먼저하고 사용하기때문에 가독성이 높아진다.

### 재귀적 CTE

재귀적 CTE는 MySQL 사용자들이 많이 기다리던 기능이라고한다.

임시 테이블 생성시 SELECT ~ UNION SELECT ~ 처럼 쿼리를 작성한다.

첫 SELECT는 비재귀적 쿼리로 임시테이블의 구조를 결정한다.

그 다음 쿼리가 재귀적 쿼리로 직전 쿼리의 결과가 입력으로 들어간다.

그리고 더이상 반환할 행이 없을 때 까지 반복한다.

> 예를들어 사원 테이블에 상위 조직장의 id를 이용해 최상위 조직장을 찾는 쿼리가 있을 수 있다.

## 윈도우 함수

윈도우 함수와 group by 함수의 가장 큰 차이점은 결과 집합이 변한다는 것이다.

group by는 그룹별로 묶어서 하나의 행을 만들어낸다. 그리고 해당 그룹의 통계를 집계함수로 나타낸다.

하지만 윈도우함수는 그룹을 하나로 묶지않고 레코드를 그대로 유지한채로 윈도우 함수의 결과를 하나의 컬럼으로 생성한다.

> 즉 중복되는 데이터를 표시하기도한다.

### FROM 절의 limit

윈도우함수와 from절의 서브쿼리를 사용했을때와 서브쿼리없이 limit을 사용한 경우 결과가 다르다.

서브쿼리가 없다면 where에 일치하는 모든 레코드를 가져와 윈도우함수를 적용하고 limit으로 제한한다.

서브쿼리가 있다면 우선 Limit에 해당하는 레코드만 가져와서 윈도우함수를 적용한다.

> 통계정보가 달라질 수 있다는 이야기다.

## 잠금을 사용하는 SELECT

InnoDB의 기본 SELECT는 잠금 없는 읽기를 지원한다.

하지만 SELECT 후 UPDATE를 해야하는 경우 사용하는 옵션이 FOR SHARE, FOR UPDATE이다.

> 질문 1 : SELECT후 UPDATE를 하는 상황은 SELECT 후 특정 조건을 만족하면 UPDATE하고 만족하지 못하면 UPDATE를 하지않는 경우에 사용하는 건가? 정확한 사용 이유를 모르겠음

FOR SHARE 는 변경만 불가하고 읽기는 가능하다.

FOR UPDATE 는 변경,읽기 모두 불가능하다.

> 물론 트랜잭션 단위안에서 해당하는 이야기다. AUTO-COMMIT에서는 불가능한 이야기다.

> 질문 2 : 스프링에서 @Transaction을 걸어주면 Auto-Commit이 비활성화되고 자동으로 BEGIN;이 되는 건가?

FOR SHARE나 FOR UPDATE가 아닌 일반 SELECT는 잠금을 대기하지 않는다.

> 질문 3 : 스프링에선 FOR SHARE, FOR UPDATE를 걸어주지않고 @Transaction만 걸어주는데 그렇다면 지금까지 트랜잭션이 무의미한 것 아닌지 (롤백의 기능만 가진건가?)
>
> 격리 수준을 지키려면 모든 쿼리에 위 조건을 붙여야하는건가?

