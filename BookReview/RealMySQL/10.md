# 실행계획

## 통계 정보

MySQL 서버는 테이블과 인덱스에대한 **개괄적인** 정보를 가지고 실행계획을 수립한다.

하지만 실제 값들이 어떤 분포를 가지는지에대한 정보는 없기때문에 정확도가 많이 떨어졌다.

그래서 8.0이후로 히스토그램을 도입했다.

> 히스토그램은 특정 값들(버킷단위)의 범위 분포를 좀 더 정확히 나타낸 정보다.

히스토그램이 도입됐다고해서기존 통계정보(테이블, 인덱스)가 필요없는 것은 아니다.

## 테이블 및 인덱스 통계 정보

기존에는 통계 정보를 메모리에 올려서 관리했다.

휘발성이 강하다는 점이 단점이였다.

5.6 이후로 디스크에 따로 저장하게됐다.

> innodb_index_stats, innodb_table_stats 테이블로 관리

각 정보들은 아래와 같다.

- 인덱스가 가진 유니크한 값의 개수
- 인덱스의 리프 노드 페이지 개수
- 인덱스 트리의 전체 페이지 개수
- 테이블의 전체 레코드 건수
- 프라이머리키의 크기 (페이지 크기)
- 프라이머리 키를 제외한 인덱스의 크기 (페이지 크기)

### STATS_AUTO_RECALC

1은 통계 정보를 자동 수집한다.

통계 정보가 너무 자주 수집되면 의도치않은 통계 정보의 변경이 생길 수 있음으로 0으로 둔다면 ANALYZE TABLE 명령어로만 수집할 수 있다.

### innodb_stats_transient_sample_pages

통계정보를 수집할 때 테이블 블록을 샘플링할지 결정하는데

이 크기를 크게할 수록 더 정확한 통계정보를 수집할 수 있다.

하지만 크기가 커질 수록 당연히 수집에 시간은 더 오래걸린다.

## 히스토그램

개괄적인 통계 정보로는 부정확한 실행계획을 세우기때문에 도입된 히스토그램은 데이터의 분포도를 참조할 수 있는 히스토그램을 도입했다.

히스토그램은 자동으로 수집되지않고 ANALYZE TABLE ... UPDATE HISTOGRAM 명령어로 수동으로 수집 관리된다.

information_schema 데이터베이스의 column_statistics 테이블에 로드한다.

또한 히스토그램은 **싱글톤 히스토그램**, **높이 균현 히스토그램** 두 가지를 제공한다.

### 싱글톤 히스토그램

버킷단위로 구분되는 히스토그램 중 싱글톤은 각 컬럼의 값과 그 컬럼의 발생빈도를 갖는다.

### 높이 균형 히스토그램

각 버킷이 범위를 갖고 시작 값 마지막 값, 발생빈도율, 버킷에 포함된 유니크한 값의 개수 등 4가지 값을 가진다.

물론 히스토그램을 삭제할 수도 있고 사용하지 않도록 할 수 있다. 하지만 쿼리 성능이 변경될 수 있으니 주의해야한다.

### 왜 사용할까?

앞서 설명했듯이 더 정확한 통계정보를 참고하게할 수 있다.

모든 값은 아니지만 개괄적인 정보보다 더 세밀하게 특정 값의 범주에서 유니크한 값의 개수 등 여러 정보를 갖기때문에 더 정확한 예측이 가능하다.

예를들어 2개의 테이블을 조인할 때 어떤 테이블을 드라이빙테이블로 놓을지는 매우 중요하다.

조인의 횟수를 줄이기위해선 히스토그램의 예측치가 매우 중요하게 작용한다.

### 히스토그램과 인덱스

주로 인덱스를 활용할 수 있는 컬럼은 히스토그램을 사용하지 않는다.

즉 히스토그램은 인덱스되지 않은 컬럼에대한 데이터 분포도를 참조한다.

## 코스트 모델

서버에서 쿼리를 처리하려면 다양한 작업이 필요하다.

- 디스크에서 페이지 읽기
- 메모리에서 페이지 읽기
- 인덱스 키 비교
- 레코드 평가

등 여러가지 작업을 처리해야한다.

위 작업들에 고정된 상수를 이용해 비용을 계산해왔다.

하지만 하드웨어와 저장된 데이터들에따라 다른 성능을 내기때문에 부정확한 연산이 수행됐다.

그래서 5.7이후로 관리자가 직접 작업들의 비율을 결정할 수 있게됐다.

코스트 모델에서 중요한 점은 각 단위의 비율을 건드리게되면 어떤 작업은 고비용이되고 저비용이되는지를 정확히 파악하는 것이다.

### 하지만 작업단위에 비율을 결정하는 것은 엄청난 전문지식과 경험이 필요하다. 쉽게 변경하지말자. 즉 기본값이 최고다. 20년 넘게 아주 잘 사용해 왔다.

## 실행 계획 확인

### 출력 포맷

EXPLAIN 에 FORMAT 키워드를 추가해서 TREE , JSON 형식으로 출력가능하다. (정보에는 차이가 없음)

### 쿼리의 실행 시간

EXPLAIN ANALYZE 는 쿼리의 실행 시간을 확인해준다.

단순히 한 쿼리의 전체 시간을 확인하는 것을 넘어서 각 단계별로 쿼리가 첫 레코드를 가져오는데 걸린 시간, 마지막 레코드를 가져오는데 걸리는 시간, 루프를 몇 번 돌았는지 등 아주 자세한 정보를 제공한다.

### id 컬럼

하나의 SELECT 쿼리에 서브쿼리로 SELECT 쿼리가 들어가기도한다.

이 경우에 SELECT 하나하나를 단위쿼리라고 한다면 id값은 2개가될 것 이다.

즉 단위 쿼리당 id값이 하나씩 증가한다.

JOIN 같은 경우는 레코드는 테이블 수 만큼 증가하지만 id값은 증가하지않는다.

보통 id값이 클수록 쿼리 안쪽 부분 또는 나중에 접근한 테이블이다.

### select_type 컬럼

#### SIMPLE

UNION이나 서브쿼리 없이 SELECT 단독이나 JOIN이 SIMPLE로 표시된다.

쿼리문이 복잡하더라도 SIMPLE 컬럼은 단 하나만 존재한다.

일반적으로 제일 바깥 SELECT 쿼리가 SIMPLE로 표시된다.

> 질문 : 제일 바깥 SELECT의 의미. 서브쿼리도 사용하지않는 쿼리인데 바깥과 안쪽의 구분이 생길 수 있는지

#### PRIMARY

UNION이나 서브쿼리를 가지는 SELECT는 가장 바깥 쿼리가 PRIMARY를 가진다.

마찬가지로 실행계획에서 단 하나만 존재한다.

#### UNION

UNION으로 결합하는 쿼리중 첫 번째는 PRIMARY 그 다음은 DERIVED 그 이후는 모두 UNION으로 표시된다.

DERIVED는 UNION 결과를 임시 테이블에 저장하기때문이다.

#### DEPENDENT UNION

IN절 내부에 UNION쿼리가 들어있고 이 쿼리가 외부쿼리에 의해서 영향을 받은 경우 DEPENDENT라고 표시된다.

#### UNION RESULT

UNION의 결과를 담아두는 테이블을 의미한다.

UNION ALL은 임시테이블을 사용하지않도록 성능이 개선됐지만 일반 UNION은 여전히 임시테이블을 사용한다.

#### SUBQUERY

from절 외에 사용되는 모든 서브쿼리는 SUBQUERY로 표시된다.

FROM절에 사용되는 쿼리는 DERIVED로 표시된다.

#### DEPENDENT SUBQUERY

안쪽 서브쿼리가 단독으로 실행되지않고 바깥쪽 쿼리에 의존적인 경우 표시된다.

일반적으로 DEPENDENT는 외부가 먼저 실행되고 내부가 실행되기때문에 처리속도가 느릴 때가 많다.

#### DERIVED

from절에서 사용된 서브 쿼리를 표시한다.

from절 서브쿼리는 임시테이블을 사용하기때문에 성능 저하가 일어날 수 있기때문에 join문으로 바꿔서 처리하는 것이 좋다.

> 최근 버전은 최적화를 수행해주긴하지만 직접 수동으로 최적화된 쿼리를 작성하는 것은 여전히 중요하다.

#### DEPENDENT DERIVED

from절의 서브쿼리는 외부컬럼을 사용할 수 있도록 개선됐는데 이를 래터럴 조인이라한다.

래터럴 조인이 사용된 경우 위 키워드가 표시된다.

#### UNCACHEABLE SUBQUERY

서브쿼리는 한 번만 실행되진않는다.

필요하다면 조건에따라 여러번 실행되기도하는데 만약 조건이 같다면 다시 실행하지않고 이전 결과를 캐싱한다.

주로 SUBQERY와 DEPENDENT SUBQUERY가 캐싱을 한다.

하지만 UNCACHEDALBE SUBQUERY는 캐싱을 하지 못한다는 것을 의미한다.

## table 컬럼

보통 <>으로 표시되는 것들은 모두 임시테이블을 의미한다.

<>안에 숫자는 참조한 id값이다.

<derived2>는 id가 2인 실행계획으로부터 생성한 임시테이블이다.

## partitions 컬럼

SELECT문에서 어떤 파티션을 가지고 실행계획을 세웠는지 표시한다.

보통 type 컬럼이 ALL로 테이블 풀 스캔을 하게되는데 전체 테이블을 풀스캔하는 것이아니라 표시된 파티션 테이블을 풀스캔하는 것이다.

파티션은 물리적으로 개별 테이블처럼 별도의 저장공간을 가지기때문에 가능하다.

> 질문 : 파티셔닝을 하는 이유

## type 컬럼

총 12가지의 값을 가질 수 있다.

**지금부터 설명할 값들은 모두 성능이 빠른 순서이다.**

맨 마지막은 ALL로 테이블 풀 스캔을 의미하고 성능이 가장 느리다.

ALL을 제외한 11가지의 값들은 모두 인덱스를 사용한다.

매우 중요한 컬럼이니 잘 살펴보자.

### system

innodb에서는 볼 수 없는 값이다.

MyISAM MEMORY에서만 사용하며 테이블에 데이터가 없거나 하나 있는 경우 접근방식이다.

### const

프라이머리키나 유니크 키를 이용하는 WHERE 조건절을 가지며 단 한건만 반환하는 쿼리를 의미한다.

다만 다중 컬럼으로 프라이머리키가 구성된 경우 일부 인덱스만 WHERE에 명시하면 const가 아닌 ref로 표시된다.

const는 모든 컬럼을 WHERE절에 명시해야한다.

> 단 한건만 반영해야하기때문에 일부 인덱스만 사용해서는 const로 표시할 수 없는 것이다.
> 서버가 쿼리를 실행 계획시 먼저 쿼리를 실행하고 통채로 상수화하기때문에 const라 부른다

### eq_ref

조인되는 쿼리의 실행계획에서 표시된다.

첫 번째 테이블을 읽고 두 번째 테이블에서 첫 테이블의 칼럼값을 이용해 검색조건에 활용하면 eq_ref가 표시된다.

다중 컬럼이라면 모든 인덱스가 표시되어야만 eq_ref가 표시된다. 즉 테이블에서 단 1건이 존재한다는 보장이있어야만 표시되는 값이다.

### ref

조인 순서에 관계없이 사용되고 프라이머리 키 제약조건은 없다.

즉 반환되는 값이 1건이 아니여도 될때 사용된다.

const, eq_ref, ref 모두 동등조건 검색에 사용되지만 ref만 반환하는 값이 하나라고 확정할 수 없다.

세 가지 모두 좋은 접근 방법이다.

### fulltext

전문 검색 인덱스를 활용하는 경우 표시되는 값이다.

### ref_or_null

IS NULL 과 같은 널비교가 기존 ref에 추가된 값이다.

성능도 나쁘지 않다.

### unique_subquery

WHERE IN(subquery)에서 사용하며 서브쿼리가 유니크한 값만 반환될때 사용된다.

### index_subquery

WHERE IN(subquery)에서 서브쿼리가 항상 유니크한 값만 반환할 수는 없다.

중복된 값이 있다면 인덱스를 이용해 중복된 값을 제거하기때문에 index_subquery라고 부른다.

### range

단 한 건만 반환하지않는 즉 인덱스 레인지 스캔형태의 접근법이다.

< > IS NULL, BETWEEN, IN, LIKE 을 이용해 검색하는 경우다.

생각보다 성능이 낮은 순위인데 인덱스 검색의 범위에따라 달라지기때문이다.

하지만 range정도면 최적의 성능을 보장한다고 봐야한다.

### index_merge

인덱스 머지는 두 개 이상의 인덱스를 사용해 결과를 합치거나 빼거나 중복을 제거하는 작업을 거친다.

이런 경우 해당 값이 type컬럼에 표시된다.

### index

오해를 많이 불러일으키는 값이다.

인덱스를 사용만 할 뿐 **효율적인 사용**은 하지 않는다.

즉 인덱스 풀 스캔을 사용한다.

테이블 풀 스캔과 달리 인덱스 페이지만 읽기때문에 디스크 I/O는 발생하지않아서 더 빠르지만 const, ref, eq_ref, range보단 훨씬 느리다.

## possible_keys 컬럼

인덱스로 사용했을 법한 목록을 나열한 컬럼이다

그다지 의미있지는 않다.

절대 해당 인덱스를 사용했다고 생각하면 안된다.

## key 컬럼

실제 사용한 인덱스의 이름을 나타내는 컬럼이다.

쿼리 튜닝에 매우 중요한 정보를 제공한다.

index_merge 외엔 1개의 인덱스만 표시된다.

## key_len 컬럼

실무에서는 다중 컬럼을 인덱스로 생성하는 경우가 많은데 key_len 컬럼은 몇 개의 컬럼으로 인덱스를 사용했는지를 나타낸다.

더 정확히는 바이트 단위로 나타내준다.

## rows 컬럼

rows는 처리해야할 레코드의 건수를 의미한다.

반환하는 값과는 다르니 주의해야한다.

rows가 전체 테이블의 레코드에 근접하게 많으면 (대략 30%이상) 테이블 풀스캔을 선택한다.

이 예측치는 정확하지는 않다.

그래서 이런경우 히스토그램을 참조하도록하면 더 정확한 예측치를 얻을 수 있다.(인덱스 검색조건은 인덱스 다이브를 사용하고 히스토그램을 사용하지는 않는다.)

> rows는 인덱스를 사용하는 조건에만 예측한다.

## filtered 컬럼

rows는 인덱스를 사용하는 조건에서만 예측하기때문에 일반적인 컬럼에대해서도 예측치를 제공해야한다.

그 정보를 제공하는 컬럼이 이 컬럼이다.

히스토그램은 이 filtered컬럼을 더 정확히 예측할 수 있도록 해준다.
