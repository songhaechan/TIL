# 언두 테이블스페이스 관리

언두 로그가 저장되는 공간을 **언두 테이블스페이스**라 한다.

언두 테이블스페이스는 보통 **시스템 테이블스페이스**에 저장됐다. 하지만 시스템 테이블스페이스는 초기화될때 한 번만 생성되기때문에 확장의 한계가 있다.

따라서 8.0이후에는 시스템 테이블스페이스가 아닌 **별도의 로그파일**에 저장한다.

별도의 로그파일로 저장되면서 동적으로 추가/삭제가 가능해진다. 트랜잭션이 커밋되면 언두로그파일은 더이상 불필요해지는데 이를 동적으로 관리해준다.

수동으로도 관리할 수 있다는 점도 알아두자.

# 언두 테이블 스페이스 구조

하나의 **언두 테이블 스페이스**는 1~128개의 **롤백 세그먼트를**가지고 하나의 롤백 세그먼트는 **1개 이상의 언두 슬롯을 가진다.**

하나의 롤백 세그먼트는 InnoDB의 페이지 크기를 16바이트로 나눈 값의 개수만큼 언두 슬롯을 가진다.

페이지가 16KB라면 롤백세그먼트는 1024개의 언두슬롯을 가진다.

일반적으로 하나의 트랜잭션은 최대 4개까지 언두 슬롯을 가지고 이렇게된다면**최대 131072개의** 트랜잭션을 동시처리가가능하다.

# 체인지 버퍼

RDBMS에서 변경 쿼리는 **데이터 변경**이외에도 **인덱스 변경**이 필요하다.

인덱스 변경은 랜덤하게 디스크를 읽어야하기때문에 변경마다 디스크에 접근하는 것은 비효율적이다.

버퍼풀에 인덱스 페이지가 있다면 인덱스를 **바로 변경**하지만 그렇지않다면 **체인지 버퍼**라는 곳에 임시로 저장하고 후에 **체인지 버퍼 머지 스레드**가 디스크에 쓰기를 수행한다.

> 반드시 중복 체크가 이루어져야하는 유니크 제약조건이 있는 인덱스는 체인지 버퍼를 사용할 수 없다.

체인지 버퍼는 **버퍼풀의 용량**과 관련이있다.

기본값은 버퍼풀의 25%를 사용하지만 만약 변경 쿼리가 많다면 이 비율을 수동으로 설정이 가능하다.

> innodb_change_buffer_max_size 설정

# 리두 로그 및 로그 버퍼

리두 로그는 앞서 살펴봤듯이 시스템이 비정상 종료됐을때 복구할 수 있는 **안전장치다**

대부분의 DBMS는 디스크보다 먼저 로그를 기록한다.(Write Ahead Log : WAL)

이렇기때문에 시스템의 비정상 종료에도 로그를 통해 비정상 종료시점의 데이터를 복구할 수 있는 것이다.

비정상 종료의 2가지 상황

1. 커밋 OK, 데이터파일기록 No

2. 롤백 OK, 데이터파일기록 OK

1번은 WAL덕분에 리두로그로 복구가 가능하다.

2번은 언두로그를 통해 복구가 가느아다.

> 2번의 경우 롤백이 됐다는 것은 커밋이전이다. 커밋하지도않았는데 데이터파일에 기록되는게 가능할까?
> 답은 가능하다. 데이터파일로 기록은 앞서 살펴봤듯이 커밋만이 디스크에 기록하는 유일한 방법은 아니다. 리두 로그가 가득차거나 더티페이지관리를 위한 주기적 Flush가 있다.

앞서 잠깐 언급했지만 리두 로그는 트랜잭션이 커밋되면 즉시 리두 로그 파일로 기록되는 시스템 변수설정을 가지고있다.

위 변수설정이 기본값이다. 그래야만 커밋된 트랜잭션을 복구할 수 있다.

하지만 이외에도 리두 로그의 디스크 기록 주기를 관리할 변수를 수동으로 설정할 수 있다.

**innodb_flush_log_at_trx_commit**은 0, 1, 2 로 설정이 가능하다.

1이 기본 값이고 0과2는 설정이 가능하다.

0은 1초에 한 번씩 디스크에 기록하고 동기화한다. 여기서 동기화는 리두로그와 데이터파일간의 기록을 말한다.

2는 트랜잭션 커밋마다 디스크로 기록은 되지만 동기화가 1초마다 한 번씩된다.

즉 0과2는 1초라는 시간동안 장애가 난다면 그 1초안에 내용은 복구가 불가능할 수 있다.

# 리두로그 아카이빙

기존에는 백업 툴을 이용해 데이터 파일을 복사하는 동안 스토리지엔진의 리두 로그에 쌓인 내용은 계속 복사했다.

데이터 변경 쿼리가 많다면 전부 추적하며 복사를 하는데 그 속도가 너무빨라 복사하기전에 리두로그가 덮어씌어진다면 백업이 불가능해진다.

하지만 리두로그 아카이빙을 설정하면 리두로그파일에 로그 엔트리가 추가될때 함께 **즉시 기록**된다.

> 책의 맥락상 기존에 리두 로그를 백업하는 방식은 리두로그 페이지가 로테이션될때(페이지가 가득찰때) 기록하는 방식이라고 추론할 수 있을 것 같다. 그래서 페이지가 가득차는 속도가 너무 빠를때 백업이 불가능해지는 상황을 말하는 것이다.

# 리두 로그 활성화 및 비활성화

리두 로그를 비활성화... 한다면 당연히 위험한 상황이 연출될게 뻔하다.

하지만 리두 로그의 디스크 기록 시스템이 대량의 데이터를 적재할땐 성능상 문제를 일으킬(?)수 있다.

이때 리두로그를 비활성화하면 적재시간을 단축할 수 있다.

그러니 잠깐 껏다가 다시 키는(잊지말아야함) 방식을 선택할 수 있다.

# 어댑티브 해시 인덱스

인덱스를 이용해 (B-Tree) 데이터를 탐색하는 것이 빠르다고 알고있을 것이다.

하지만 결국은 상대적인 기준이다.

B-Tree로 탐색하더라도 루트부터 리프노드까지 탐색해야하는데 이게 만약 수 천개의 스레드가 실행한다면 성능이 떨어질 수 밖에없다.

이런 성능을 뒷받쳐줄 어댑티브 해시 인덱스라는 자료구조가 있다.

B-Tree를 탐색하지않고 어댑티브 해시 인덱스를 사용하게되면(기본적으로 활성화돼있다.) 훨씬 좋은 효율을 보인다.(이 효율도 상황에따라 다르다.)

어댑티브 해시 인덱스는 자주 사용하는 데이터를 캐싱한다.

해시 인덱스는 **인덱스 키 값**과 인덱스 키 값이 저장된 **데이터 페이지 주소** 쌍으로 관리된다.

인덱스 키 값은 B-Tree 인덱스의 고유번호(Id)와 B-Tree 인덱스의 실제 키 값 조합으로 생성된다.

이유는 어댑티브 해시 인덱스는 하나만 존재해야하기때문이다.

데이터페이지 주소는 데이터 페이지의 메모리 주소를 가진다.

여기서 **메모리 주소**란 버퍼풀에 적재된 페이지의 주소를 의미한다.

그렇기때문에 버퍼풀에 올라온 데이터페이지만 **어댑티브 해시 인덱스**에서 관리된다.

버퍼풀에서 데이터페이지가 제거되면 당연히 어댑티브 해시 인덱스에서도 제거된다.

### 성능에 도움이 되지않는 상황

- 디스크 읽기가 많은 경우

  버퍼풀에 적재된 페이지만 해시 인덱스에 등록되기때문에 버퍼풀을 거치지않는 디스크 읽기가 많다면 비효율적이다.

- 특정 패턴의 쿼리가 많은 경우(조인이나 LIKE패턴 검색)
- 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우

### 성능에 도움이 되는 상황

- 디스크 읽기가 많지 않은 경우

- 동등 조건 검색이 많은 경우

- 쿼리가 데이터 중에서 일부 데이터에만 집중되는 경우

일반적으로 어댑티브 해시 인덱스는 활성화돼있기때문에 무조건 키 값을 해시 인덱스에 검색해야한다는 것도 비효율성을 만든다.

또한 삭제쿼리도 해시 인덱스에서 매번 제거해야하기때문에 일이 두배(?)가 되는 상황이 발생한다.

서비스의 상황에따라 켜고 끌지 선택해야한다.

## MySQL 로그 파일

로그 파일을 이용하면 서버의 상태나 부하를 일으키는 원인을 쉽게 찾아서 해결할 수 있다.

로그 파일을 확인하는 습관을 들이자!

### 에러 로그 파일

실행 중 발생하는 에러나 경고 메세지가 출력되는 로그 파일이다.

### 시작하는 과정과 관련된 정보성 및 에러 메세지

지금까지 많은 시스템 변수 설정을 알아봤다.

변수에따라 성능도 달라지고 혹은 치명적인 데이터 손실을 일으킬 수도 있는 변수도 있다.(비활성화한 변수를 다시 활성화시키지 않았다든지 ex) 리두로그를 끄고 다시 안킴(매우 큰일))

이 변수 설정을 로그 파일을 통해 확인할 수 있다.

### 트랜잭션 복구 메세지

디스크에 기록하지 못한 데이터는 다시 기록하는 작업을 하는데 이때 간단한 메세지가 출력한다.

이 단계가 가장 해결하기 어려운 문제일 경우가 많다.

자세한건 자동화된 장애 복구를 참고!

### 쿼리 처리 도중 문제 에러 메세지

사전 예방이 매우 어려운 경우다.

이러한 로그를 확인해보는것이 DB의 숨겨진 문제를 알 수 있게해준다.

### 비정상 종료된 커넥션 메세지

네트워크 장애로 커넥션을 얻지 못한다면 이런 에러메세지를 많이 볼 수 있다.

네트워크 장애의 원인을 살펴보는 것이 좋다.

### MySQL의 종료 메세지

가끔 아무도 모르게 종료되거나 아무도 모르게 재시작 되는 경우가 있는데 이런 경우엔 로그를 확인해 왜 종료됐는지를 확인해야한다.

자세한 내용은 메뉴얼참고

### 제너럴 쿼리 로그 파일

서버에 실행되는 모든 쿼리를 로그파일로 기록할 수 있다.

테이블에 기록할 지, 파일에 기록할 지 결정할 수 있다.

에러가 발생해도 일단 요청이 들어온 쿼리는 모조리 기록된다.

### 슬로우 쿼리 로그

서비스가 운영중에 쿼리 튜닝은 매우 어렵다.

슬로우 쿼리 로그는 이 경우 쿼리튜닝에 상당한 도움이 된다.

슬로우 쿼리 로그는 설정한 시간(쿼리실행시간)을 넘어가는 쿼리를 기록하는 것이다.

즉 이름 그대로 쿼리 실행시간이 예상한 시간보다 늦은 경우에 기록되고, 중요한 점은 정상동작한 쿼리만 기록된다.

제너럴 쿼리 로그와같이 테이블에 기록할지 파일에 기록할지 **log_output** 옵션을 TABLE, FILE로 설정할 수 있다.

### 로그파일 분석

- Time 은 쿼리가 **종료된 시점**이다.(시작시간이 아니다.)

- User@Host 는 쿼리를 실행한 사용자 계정이다.

- Query_time은 쿼리 실행에 걸린 전체 시간이다.

- Lock_time은 잠금 대기시간이다.

  이 부분이 혼동되기 쉬운데, 테이블 잠금 대기시간 뿐만 아니라 **잠금 체크**와 같은 코드 실행 부분까지 포함되기때문에 이 시간이 매우 작다면 무시해도 무방하다.(실제 잠금이 걸리지않았을 가능성이 높기때문이다)

- Rows_examined 는 쿼리가 처리되기위해 몇 건의 레코드에 접근했는지를 의미한다.

- Rows_sent는 사용자에게 보낸 처리결과다.

  examined 는 높지만 sent가 상당히 적다면, 즉 **적은 양의 응답을 위해 여러 레코드를 읽은 경우** 튜닝할 가치가 있는 쿼리다.(집합 함수는 제외다. 함수 특성상 많은 레코드를 읽어서 적은 행을 반환하기때문)

Lock_time 이 InnoDB에서도 높을 수 있다. (행잠금이 아닌 테이블 잠금일 가능성이 높다.)

테이블잠금도 InnoDB에서 일어날 수 있는데 이것은 **MySQL 엔진**차원에서 잠금을 건것이다.

뒤에서 자세히 설명

이 외에도 슬로우쿼리 통계, 시간순 랭킹, 실행 빈도 실행 횟수 등 상세 정보를 출력할 수 있다.
