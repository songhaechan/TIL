## 잠금 테이블 선택

FOR UPDATE 나 FOR SHARE의 경우 JOIN을 이용한 SELECT에서 JOIN을 위한 테이블 모두 잠금을 건다.

하지만 FOR UPDATE OF 테이블명(or alias)로 특정 테이블만 잠금을 걸 수 있다.

## NOWAIT & SKIP LOCKED

우선 FOR UPDATE 구문에서만 사용할 수 있다는 것을 명확히해두자.

### NOWAIT

이미 잠금이 걸린 레코드에 FOR UPDATE로 접근한다면 당연히 잠금을 대기해야한다.

하지만 사용자 입장에선 애플리케이션 화면만 보고 주구장창 기다려야한다.(어느정도인지는 모르겠지만)

차라리 에러를 뱉고 다시 트랜잭션을 시작하는 편이 좋을 수 있다.

이때 NOWAIT을 사용하면 잠금을 대기하지않고 에러를 뱉는다.

### SKIP LOCKED

사실 이걸 왜 쓰나 했다.

선행 트랜잭션이 잠근 레코드는 건너뛰고 같은 조건의 바로 다음 행을 가져오는 옵션이다.

실제 책의 예제를 보면 WHERE 문 조건과 일부만 같은 행을 가져온다.

이를 NOT-DETERMINISTIC (비확정적)이라 한다.

쉽게말하면 어떤 행을 가져올 지 확정되지않았다는 것인데...

이 명령을 사용하는 아주 좋은 예시가 있다.

바로 동시다발적으로 요청이 몰리는 선착순 쿠폰이벤트가 그 예시다.

우선 쿠폰을 1000개 생성하고 이 쿠폰을 FOR UPDATE로 처리한다면 1000개의 요청 중 제일 첫 요청만 트랜잭션이 시작되고 나머지는 모조리 대기한다.

> 첫 행으로 모든 요청이 쏠린다.

이때 SKIP LOCKED를 사용하면 첫 행을 건너뛰고 다음 행을 가져온다.

마치 1000건이 동시처리되는 효과를 볼 수 있다.

> 물론 행을 건너뛰는 시간도 있어서 정확히 동시처리는 아니다.

## INSERT

### INSERT IGNORE

프라이머리키나 유니크 인덱스가 중복된 INSERT를 시도하면 에러를 뱉고 트랜잭션은 롤백된다.

하지만 데이터가 정교하지않아도 되는 경우 IGNORE를 사용하면 에러가 아닌 경고를 뱉고 다음 레코드를 진행한다.

> INSERT를 하지않는 것은 동일하나 다음 문장을 실행 하느냐 마느냐가 다르다.

또한 NULL이 들어오면 안되는 컬럼어 NULL이 들어간다면 기본 INSERT는 에러를 뱉고 롤백하지만 IGNORE은 경고만 보내고 Default값으로 채워 넣는다.

### INSERT ON DUPLICATE KEY UPDATE

INSERT 시 키가 중복일 때 UPDATE를 하도록하는 키워드다.

원래는 키가 중복이라면 에러를 뱉는다.

이 방법대신 REPLACE문이 있긴하지만 내부적으로 DELETE 후 INSERT하는 쿼리여서 성능이 좋지못하다.

아무것도 없는 행이라면 ON이하는 무시되고 원래 INSERT문처럼 작동하고 이미 존재한다면 UPDATE를 실행한다.

일일 방문자 통계같은 경우 (게시글의 View?) 이런 방식을 사용할 수 있다.

### Load Data

RDBMS에 빠르게 데이터를 적재할 수 있는 방법이다.

MySQL 엔진과 스토리지엔진 사이엔 핸들러api가 존재해 쿼리마다 핸들러가 작동한다는 것을 앞에서 배웠다.

Load Data는 이 핸들러의 호출을 최소화해 작동하기때문에 성능이 빠르다.

다만 단일 스레드, 단일 트랜잭션으로 작동하기에 매우 큰 데이터를 적재할땐 문제가된다.

일단 단일 트랜잭션이라면 언두로그가 과다하게 쌓일 것이다.

다른 트랜잭션이 파악해야하는 언두로그가 많아지며 오버헤드가 생길 것이고 디스크로 언두로그가 기록되는 I/O 오버헤드도 존재할 것이다.

INSERT ''' SELECT 문으로 데이터를 잘라서 테이블을 복사하는 방법을 택하는 것이 좋다.

### 대량 INSERT의 성능을 높이는 방법

몇 건 안되는 INSERT는 성능 튜닝할 것도 없다.

> 사실 할 부분이 없다.

하지만 대량 데이터는 성능에 차이가 벌어지는 요소가 있는데

LOAD DATA에서 csv파일로 덤프받아서 INSERT하는 경우라면 이미 정렬된 csv파일이냐 그렇지 않느냐에 따라 2배가량 성능 차이가 난다.

### 왜 차이가 나지?

INSERT는 자신이 들어갈 곳을 알야아한다.

자신이 들어갈 곳은 스토리지 엔진이 인덱스 페이지를 뒤져서 찾게되는데 만약 정렬돼있지않다면 인덱스 페이지를 여기저기서 뒤져야한다.

즉 Random Access가 발생하는데 이미 정렬된 상태에선 새로운 인덱스 페이지를 디스크로부터 읽어올 필요가 없기때문에 성능 차이가 벌어진다.

> 버퍼풀을 키운다면 이 차이는 줄어들 수도 있다.

## 프라이머리키 선정

프라이머리키는 성능에 매우 중요한 위치를 갖는다는 것은 계속해서 읽어왔다.

하지만 문제는 SELECT와 INSERT,DELETE 성능 모두를 높이는 것은 불가능하다. (트레이드오프)

로그기록같은 경우 프라이머리키는 단조증가 단조감소하는 인덱스로 선정한다.

> SELECT보다 INSERT비율이 압도적으로 많기때문

하지만 일반 비즈니스에선 SELECT 비율이 높다.

자연스레 세컨더리 인덱스도 많아지게된다.

자주 사용되는 검색조건으로 프라이머리키를 선정하고 세컨더리 인덱스를 생성해야한다.

대부분의 테이블 구조에서 대량의 데이터가 적재되는 테이블은 10%밖에 안된다고한다.

이러한 테이블을 타겟으로 잡고 성능 튜닝을해야한다.

## UPDATE DELETE

### UPDATE DELETE ... ORDER BY ... LIMIT

많은 데이터를 한꺼번에 update delete 쿼리를 날리면 부하가 심하다.

이때 정렬 후 상위 몇건만 업데이트하는 쿼리를 작성할 수 있다.

### JOIN UPDATE

```sql
update tb_test1 t1, employees e
set t1.first_name = e.first_name
where e.emp_no=t1.emp_no;
```

우선 employees 테이블과 tb_test1 테이블을 조인한다.

그 후 e의 컬럼값을 t1의 컬럼으로 update하는 쿼리다.

이렇게 조인 후 다른 테이블의 컬럼값을 가져와 update하는 방식이다.

그루핑도 가능한데 일반적인 group by는 에러가 발생하고 파생 테이블을 만드는 방식(임시테이블)을 선택해야한다.

일반적인 웹서비스 시스템에선 데드락이 발생하기 쉽기때문에 자주 사용하지않는다.

> JOIN DELETE 도 조인한 결과 중 특정 테이블의 레코드만 삭제가 가능하다.

## 온라인 DDL

스키마를 변경하는 알고리즘은 3가지가 있다.

보통 ALTER TABLE 명령을 입력하면 이 세가지 알고리즘 중 변경에 적합한 알고리즘을 선택한다.

1. INSTANT
   데이터는 전혀 변경하지않고 메타데이터만 변경하고 작업을 끝낸다.
2. INPLACE
    임시테이블로 복사는 하지않는다. 하지만 리빌드가 발생할 수 있다. ex 프라이머리 키 추가
    시작시점과 종료시점엔 읽고 쓰기 불가능하지만 매우 짧은 시간이여서 영향이 미미하다.
3. COPY
   임시테이블을 생성해 몽땅 복사한다. 테이블 읽기만 가능하다.

## 컬럼 변경

### 컬럼 추가

컬럼을 추가할 때 추가되는 컬럼이 맨 마지막인 경우 INSTANT 알고리즘으로 선택돼 매우 빠르게 끝나지만 중간에 넣는 경우 INPLCAE알고리즘이 선택된다.

> 테이블이 크다면 중간에 컬럼을 추가하는 경우 INPLACE알고리즘이 선택되기때문에 테이블을 리빌드(데이터 재구성)하는데 시간이 오래 걸릴 수 있다.

### 컬럼 타입 변경

타입 변경은 주로 문자열의 길이 확장일 수 있다.

문자열의 타입에 따라 테이블 전체를 리빌드할지 하지않을지 결정한다.

최대 가질 수 있는 길이가 달라지는 경우가 있다. UTF8MB4 문자셋이 그 예시인데 한 글자가 최대 4바이트를 갖기때문에 전체 리빌드가 필요하다.

## 인덱스 변경

기본 키, 유니크 인덱스, 일반 인덱스 생성은 INPLACE(리빌드가 필요할 수 있는 알고리즘)과 LOCK은 발생하지않는다.

하지만 전문 검색, 공간 검색은 INPLACE 알고리즘 + SHARED락을 걸어야한다.

> SHARED는 공유락 (읽기락) 으로 읽기락이라해서 읽기를 락거는 것이아니라 쓰기를 락건다.

## 인덱스 삭제

세컨더리 인덱스 삭제는 INPLACE를 사용하고 리빌드를 필요로하지 않아서 빨리 처리되지만 프라이머리키는 세컨더리 인덱스의 모든 리프노드에 적힌 포인터(기본키)를 제거해야해서 임시테이블을 이용한다.

## 쿼리 성능 테스트

### 성능에 영향을 미치는 요소

1권에서 봤듯이 성능엔 MySQL서버가 가질 수 있는 버퍼와 캐시의 크기 그리고 종류가 성능에 영향을 미친다.

### 운영체제의 캐시

일반적으로 디스크 I/O가 발생한다는 말의 의미는 스토리지엔진의 Sys Call이다.

운영체제는 디스크로부터 값을 읽어 반환하고 이 값을 캐싱한다.

같은 요청이라면 디스크를 읽지않고 캐시 데이터를 MySQL에 건내준다.

하지만! InnoDB는 운영체제 캐시를 이용하지않는 Direct I/O를 사용하기때문에 캐시에대한 영향은 적다.

> MyISAM 스토리지엔진은 이러한 캐시를 사용한다.

그래서 운영체제의 캐시를 제거하고 쿼리를 테스트하는 것이 좋다.

> MySQL을 재시작해도 운영체제 캐시는 없어지지 않기때문에 운영체제의 캐시자체를 없애야한다.

### InnoDB 버퍼풀

InnoDB는 내부적으로 버퍼풀을 이용해 데이터페이지, 인덱스 페이지를 캐싱한다.

이 버퍼풀은 MySQL을 재시작해도 유지된다.

> 종료시점에 덤프 후 시작 시점에 재적재한다.

innodb_buffer_pool_load_at_startup 변수가 기본적으로 ON이기때문에인데 이 값을 OFF로 변경한다면 깨끗한 버퍼풀에서 쿼리를 테스트할 수 있다.

### 독립된 MySQL 서버

애플리케이션 레벨에서 테스트하는 것은 여러 요소가 영향을 미친다.

네트워크나 웹서버에 따라 영향을 받는데 이런 영향이 없는 설치된 Host OS에서 직접 쿼리를 실행하는 것이 좋다.

### 쿼리 테스트 횟수

일반적으로 버퍼풀이 깨끗한 상태(콜드 상태)에서 테스트하기보단 워밍업된 상태에서 진행한다.

또한 버퍼 풀의 크기가 필요로하는 데이터의 크기보다 작다면 플러시와 캐싱 작업이 빈번히 일어나기때문에 초반 쿼리는 시간이 더 걸리는 편이다.

그래서 한 두번 실행으로 판단하지말고 6-7번은 실행하고(워밍업시키고) 평균값으로 측정해야한다.



