## 불리언

BOOL 이나 BOOLEAN으로 타입을 정의해도 결국 TINYINT로 생성된다.

TRUE나 FALSE로 비교해서 조회하더라도 1과 0이 조회된다.

## 동등 비교 <=>

<=>는 Null 값을 비교가능하게해준다.

= 는 null값 비교가 불가능하다.

## REGEXP

정규표현식을 이용해서 조회할 수 있다.

POSIX 표준으로 구현돼 있다.

중요한 점은 WHERE 조건 절에 단독으로 사용하면 인덱스 레인지스캔을 이용할 수 없어서 성능상 좋지않다.

다른 조건(인덱스를 사용하는)과 결합해서 사용하길 권장한다.

## LIKE

LIKE 연산자에서 가장 중요한 점은 %keyword 형식은 인덱스를 사용할 수 없다는 점이다.

인덱스를 읽는 특성이 좌측부터 상수 문자열을 비교하기때문이다.

## BETWEEN

BETWEEN은 범위를 줄여준다.

2개의 컬럼으로 구성된 인덱스에서 첫 번째 인덱스의 범위를 BETWEEN으로 줄여주고 동등연산으로 두 번째 조건으로 조회하는 경우를 생각해보자.

첫 조건의 범위가 매우 넓고 두번째에서는 동등연산으로 딱 한 건만 반환하는데 읽어야하는 레코드가 매우 많을 것이다.

즉 인덱스 앞쪽에 있는 컬럼의 **선택도**가 떨어질때 IN절로 변경해서 사용하면 성능이 개선된다.

```sql

select from dept_emp
where dept_no in ('d003','d004','d005')
and emp_no = 1001;

```

위와같이 처리하면 된다.

동등 비교연산이기때문에 딱 3건만 읽으면 된다.

IN 절에 서브쿼리를 작성하면 세미조인 최적화로 조인쿼리가 나가게된다.

## IN

IN연산에서 튜플을 사용하는 경우에 항상 테이블 풀스캔을 했지만 8.0이후로 최적화되어 인덱스를 최적으로 사용할 수 있게됐다.

NOT IN은 인덱스 풀 스캔을 사용한다. 범위를 줄일 수 없기때문이다.

## IFNULL() 함수

NULL인 경우 다른 값을 대체해주는 함수다.

ISNULL()은 단순히 NUL인지 아닌지를 1과0으로 조회된다.

## CASE WHEN THEN END

일반 프로그래밍언어의 switch문과 같다.

어떤 경우는 서브쿼리를 실행해야하지만 어떤 경우에는 서브쿼리를 실행하지 않아야하는 경우를 생각해보자.

CASE WHEN 이 없다면 별다른 방법이 없다. 언제나 서브쿼리를 실행하도록해야하는데, CASE WHEN은 조건에 부합하면 THEN절 이하를 실행하게할 수 있다.

## SELECT 처리 순서

거의 모든 쿼리가 실행되는 순서는 2가지 정도다.

예외는 CTE와 윈도우 함수이다.

1. 드라이빙 테이블을 선정하고 드리븐 테이블과 조인을 수행한다.(WHERE 조건 적용)

2. GROUP BY
3. DISTINCT
4. HAVING 조건
5. ORDER BY
6. LIMIT

각 요소가 없는 경우는 있어도 이 순서는 변하지않는다.

다음은 예외적으로 GROUP BY 없이 ORDER BY절만 사용되는 쿼리의 순서다.

1. 드라이빙테이블 WHERE적용
2. ORDERBY
3. 드리븐 테이블과 조인
4. LIMIT

## where, group by, order by 인덱스 사용

### 기본 규칙

인덱스를 사용하려면 인덱스 컬럼 자체만 사용해야지 절대 변형해 사용하면 인덱스를 사용하지 못한다.

또한 타입이 일치해야한다.

### where 절의 인덱스 사용

where 문의 인덱스는 크게 **작업 범위 결정 조건**, **체크 조건**으로 사용된다.

where문에 작성하는 인덱스 컬럼의 순서는 중요하지않다.

옵티마이저가 최적화하기때문이다.

가장 중요한 점은 인덱스 생성 순서이다.

그리고 작업 범위 결정 조건 뒤에 오는 인덱스는 체크 조건으로 사용된다.

인덱스의 순서는 성능에 영향을 미치기때문에 주의깊게 고려해야한다.

또한 where에 or절을 사용하면 비교할 레코드가 늘어나기때문에 아예 다른 방식으로 실행된다. (주의하자)

### group by 절의 인덱스 사용

group by는 where과 다르게 명시한 순서가 인덱스 생성 순서와 정확히 동일해야한다.

명시된 컬럼 모두 인덱스가 생성돼있어야한다.

### order by 절의 인덱스 사용

group by와 비슷하게 명시한 컬럼의 인덱스 생성 여부와 순서가 중요하다.

추가로 정렬 순서가 인덱스 순서와 정확히 동일하거나 정반대인 경우에만 사용이 가능하다.

### where과 order by 또는 group by

1. where과 order by 가 모두 인덱스를 사용한다면 where문과 order by가 연속된 인덱스로 나열돼 있어야한다.

2. where만 인덱스를 사용한다면 order by는 인덱스를 사용해 정렬하지못하고 별도의 정렬 처리 과정을 거친다. where에 일치하는 레코드가 적다면 괜찮은 방법이다.

3. order by 절만 인덱스를 사용한다면 where 절은 인덱스를 이용하지못하고 주로 많은 레코드를 정렬해야하는 경우에 사용한다.

### group by 와 order by 인덱스 사용

group by와 order by에 명시된 인덱스의 순서와 내용 모두 같아야지만 하나의 인덱스를 사용해 두 절 모두 처리할 수 있다.

### NULL 비교

NULL은 mysql에서 하나의 값으로 간주하여 인덱스로도 사용될 수 있다.

일단 결론부터 말하자면 is null 을 사용해 비교하자. 이 방법은 인덱스를 사용하게된다.

ISNULL()함수는 인덱스를 사용하지못하는 경우가 있기때문에 되도록 IS NULL을 사용하자.

### Short-Circuit Evaluation

&& 로 연결된 두 가지 조건 중 첫 번째 조건이 만족하지않다면 두 번째 조건은 실행하지않는 방식으로 프로그래밍언어는 최적화를 수행한다.

이와 같은 맥락으로 where문의 조건들을 살펴보자.

where문의 조건들이 인덱스가 사용가능하다면 순서는 상관없다 어차피 인덱스 컬럼의 생성 순서에따라 실행되기때문이다.

하지만 where문이 인덱스를 사용하지않는다면 where문에 명시된 순서대로 실행된다.

이때 작업 부담이 큰 조건을 앞쪽에 명시하면 (작업 범위를 많이 줄여주지 못하는 코드들) 성능이 저하된다.

되도록 부담이 큰 쿼리(서브쿼리 등)은 AND연결 시 뒤쪽에 배치해야한다.
