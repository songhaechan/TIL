순차 I/O , 랜덤 I/O 와 HDD , SSD
=

HDD와 SSD 모두 순차 I/O가 더빠르고 랜덤 I/O가 더 느리다.

HDD는 디스크헤더의 이동이 성능의 핵심인데 순차I/O가 디스크헤더의 이동이 더 적기때문이다.

SSD의 경우 HDD보다 모두 성능적으로 뛰어나지만 마찬가지로 순차I/O가 랜덤I/O보다 빠르다.

**즉 쿼리 튜닝의 핵심은 랜덤I/O를 줄이는 것이다.**

> 큰 테이블의 대부분을 읽는 경우 순차I/O를 사용하기때문에 레인지스캔보다 풀스캔(순차I/O)을 선택한다.

인덱스
=

인덱스는 데이터의 고유값을 이용해 **항상** 정렬된 상태를 유지한다.

그렇기에 INSERT, DELETE, UPDATE의 성능을 희생해야한다. (항상 정렬된 상태를 유지해야하기때문에)

하지만 항상 정렬된 상태를 유지하기때문에 SELECT(조회)성능은 매우 높아진다.

B-Tree 인덱스
=

기본구조는 **루트 노드, 브랜치 노드, 리프 노드, 데이터파일**

일반적으로 **데이터파일**은 정렬된 상태는 아니다.(빈공간이 생기면 그곳에 데이터를 임의로 저장한다.)

>InnoDB의 경우 레코드는 클러스터되어 프라이머리 키 순서로 저장된다.(자세한건 나중에)

루트노드부터 브랜치, 리프노드까지 인덱스 키를 범위를 갖고 자른다.

루트노드는 가장 크게 자르고 뒤로 갈 수록 세세하게 자르고 자식노드의 주소를 동시에 갖기때문에 자식 노드를 탐색할 수 있다.

리프 노드는 데이터파일을 찾기위한 주소가 같이 기록된다.(InnoDB의 경우 프라이머리 키)

인덱스 키 추가 및 삭제
=

인덱스를 추가한다면 앞서 살펴봤듯 리프노드에 삽입하기위해 **적절한 위치를 탐색**해야한다. 리프노드가 꽉찼다면 split(분리)해야한다.(이러한 과정때문에 새로운 키를 추가하는 작업이 비용이 많이든다.)

테이블에 인덱스가 많다면 그만큼 시간은 오래걸리기때문에 무분별한 인덱스생성은 select쿼리를 제외한 쿼리의 성능을 매우 낮춘다.

또한 InnoDB는 유니크 인덱스, 프라이머리 키는 바로 인덱스에 추가하지만 세컨더리인덱스의 경우 바로 추가하지않을 수 있다.

>체인지 버퍼 참조

인덱스 키 검색
=

인덱스를 사용하는 이유는 당연 검색 성능을 위해서다.

UPDATE나 DELETE도 항상 검색이 선행되기때문에 이 경우에도 사용된다.

다만 인덱스를 임의로 변경(함수로 계산하는 경우)하고 검색한다면 절대 인덱스로 검색성능 향상을 기대할 수 없다.

적절한 인덱스 설계를 하지않으면 넥스트키락(갭락)으로인해 불필요한 레코드를 잠글 수 있다.

> 예시 : 인덱스로 이름을 설정하고 이름을 기준으로 delete한다면 where문의 이름 전체를 락걸어버린다.

인덱스 키 값의 크기
=

B-Tree에서 인덱스 페이지는 16KB로 돼있다.(4~32KB)

기본적으로 인덱스 페이지의 인덱스 키는 16파이트 자식노드주소는 12바이트 정도로 인덱스키를 585개 저장가능하다.

인덱스 키값이 커진다면 인덱스키를 그만큼 적게 저장하게되고 SELECT쿼리의 성능이 1번 읽을 데이터들을 2번에 걸쳐 읽을 수 있다.

버퍼풀의 메모리 사용량에도 인덱스 키 값의 크기가 영향을 미친다.

키값의 크기는 자연스럽게 B-Tree의 깊이와도 연관이 돼 있다.

키 값이 커지면 그만큼 저장할 인덱스 키가 줄어들고 탐색해야할 깊이가 깊어지기에 인덱스 키값은 작게 만드는 것이 좋다.

선택도 = 기수성
=

인덱스의 유니크한 값의 개수를 나타낸다.

유니크한 값의 개수가 많을 수록 조회쿼리의 성능이 올라간다.

쉽게말해 중복된 인덱스가 적을 수록 조회 시 불필요하게 읽은 레코드가 줄어든다는 의미다.

선택도(기수성)은 쿼리의 효율에 큰 영향을 미친다.

읽어야할 레코드건 수
=

무조건 인덱스를 통한 탐색이 좋은가?

그렇지 않다. 테이블 전체 데이터의 20~25%의 데이터를 읽는다면 옵티마이저는 풀스캔이 더 적절하다고 판단하고 실제로 그렇다.

인덱스 레인지 스캔
=

가장 대표적인 방법이고 뒤에서 설명할 두 방식보다 빠르다.

인덱스의 범위가 결정됐을 때 사용하는 방식이다.(ex BETWEEN)

1. 저장된 인덱스 위치를 찾는다 (인덱스 탐색)
2. 필요한 만큼 인덱스를 쭉 읽는다(인덱스 스캔)
3. 인덱스키와 레코드 주소를 이용해 저장된 페이지를 가져온다.

문제는 실제 데이터페이지에 접근하면 랜럼 I/O가 레코드 건수 만큼 발생한다는 것이고 그렇기때문에 인덱스를 통한 읽기가 20~25%를 넘으면 테이블을 직접읽는 것이 효율적이다.

인덱스 풀 스캔
=

인덱스가 A,B,C 컬럼으로 이루어져 있을 때 B나 C로 검색할 경우 **인덱스 풀 스캔**을 이용해 인덱스 전체를 탐색한다.

일반적으로 인덱스에 명시된 컬럼만으로 조건을 처리한다면 테이블에서 전체를 읽는것보다 훨씬 빠르다.(직접 데이터페이지에 접근하지않아도 되기때문)

루스 인덱스 스캔
=

필요하지 않은 인덱스는 스킵하고 다음으로 넘어가는 방식이다.

예를들어 GROUP BY와 MIN() MAX() 함수를 사용하는 경우 모든 인덱스를 찾을 필요는 없다. 가장 위 가장 아래만 찾으면 되기때문에 최소나 최대를 찾았다면 즉시 다음 인덱스로 넘어간다.

인덱스 스킵 스캔
=

인덱스 컬럼이 (A,B)로 구성된 경우를 생각해보자.

조건문에 A와 B가 모두 사용돼야 인덱스를 사용하는 쿼리이다.

B만 사용하게되면 앞서 살펴본 인덱스 풀 스캔(인덱스를 효율적으로 사용하지못함)을 하게되고 이는 매우 비효율적이다.

>심지어 조회하는 쿼리의 컬럼이 인덱스 컬럼이 아니라면 인덱스 풀스캔을 사용조차하지않는다.

8.0이후로는 두번째 인덱스만으로도 인덱스스캔이 가능해졌다.

내부적으로 A컬럼의 조건문을 생성해 다시 쿼리를 날리는 방식으로 작동한다.

### 단점

A컬럼의 유니크한 값의 개수가 적어야함(많으면 새롭게 생성하는 쿼리가 그만큼 많아짐)

인덱스에 존재하는 컬럼만으로 처리가 가능해야함(만약 다른 컬럼이 포함됐다면 풀스캔을 실행함)

다중 칼럼 인덱스
=

다중 컬럼 인덱스에서는

**인덱스 내에서 각 칼럼의 순서가 매우 중요하다.**

A,B,C 로 이루어진 인덱스에서 B는 A에 C는 B에 의존하여 정렬되기때문에 B의 값이 작더라도 리프 노드의 최하단에 놓일 수 있다는 것이다.

인덱스 스캔 방향
=

인덱스를 생성할때 기본적으론 항상 오름차순 정렬이 된다.

> 복합 인덱스를 생성할때 정렬방식을 혼합할 수 있다.

인덱스가 오름차순으로 정렬돼있든 내림차순으로 정렬돼있든 **옵티마이저는 어느 방식이 빠른지 알고있다.**

즉, 정렬된 방식에 상관하지않고 옵티마이저는 스캔 방향을 조정해서 실행계획을 생성한다.

### 내림차순 인덱스의 필요성

내림차순 인덱스는 왜 필요할까?

이것은 인덱스 스캔시 **정순 스캔**, **역순 스캔**과 관련이 있다.

기본적으로 인덱스는 오름차순이다.

이 인덱스를 이용해서(오름차순) 전체 테이블의 데이터를 내림차순으로 정렬하는 쿼리는 **역순으로 읽어야한다**.

하지만 InnoDB는 정순스캔에 적합한 자료구조를 가지고있다. 인덱스 레코드가 단방향으로 연결된 자료구조를 가진다.

이때문에 대략 역순스캔은 정순스캔에비해 28%느리다.

이렇기때문에 만약 오름차순을 역순으로 읽을 필요가있는 쿼리가 빈번하다면 차라리 **내림차순 인덱스**를 생성해서 **정순 스캔**을 이용하도록하는 것이 성능상 좋다.

B-Tree 인덱스의 가용성과 효율성
=

### 비교 조건의 종류와 효율성

다중 컬럼 인덱스에서 각 컬럼의 순서를 바꾸는 것만으로도 효율이 달라진다.

> WHERE dept_no = 'd002' AND emp_no >= 10114;

칼럼 순서가 dept_no, emp_no 인지 emp_no, dept_no에따라 효율이 달라진다.

위 쿼리 경우 dept_no, emp_no로 생성한 인덱스의 효율이 더 좋다.

후자는 필터링이 동작하기때문에 효율이 떨어진다.

### 인덱스의 가용성

사용자의 이름 칼럼을 인덱스로 생성하고 %chan으로 검색하면 인덱스를 탈까?

인덱스를 절대 타지않는다.

인덱스는 좌측알파벳부터 정렬을 시작해나간다.

%chan은 어느부분부터 정렬이 이루어졌는지 알 수가 없다.

결국 풀스캔을 하게된다.

다중 컬럼중에서 2번째 컬럼을 기준으로 검색하는 경우도 마찬가지로 인덱스를 타지않는다.(풀스캔, 인덱스 컬럼을 조회하는 경우라면 인덱스 스킵 스캔)

### R-Tree 인덱스

2차원 공간을 저장하는 데이터 구조이자 알고리즘이다.

B-Tree는 1차원 스칼라값인 반면 R-Tree는 2차원 도형을 저장한다고 생각하면 된다.

인덱스는 B-Tree와 같이 루트,브랜치,리프노드로 구성된다.

흔히 현재 위치로부터 5km이내에 있는 음식점을 찾는 쿼리에 적접하다.

### 전문 검색 인덱스

B-Tree는 기본적으로 좌측 일부 일치, 전체 일치 (LIKE abc%, LIKE abc) 검색만 가능하다.

> 이유는 이전에 설명 (인덱스의 특징)

전문을 검색하는 경우에는 B-Tree를 이용하지않고 n-gram 알고리즘을 사용한다.

2-gram알고리즘은 2글자 단위로 글자를 쪼개서 인덱싱한다.

그리고 B-Tree에 똑같이 저장한다.

>불용어 처리는 265p에 자세히 나온다

### 전문 검색 사용

우선은 당연히 인덱스를 생성한다.

doc_body TEXT

FULLTEXT KEY fx-doecbody(doc_body) WITH PARSER nram

이렇게 전문 검색용 인덱스를 생성한다.

그런데 LIKE %ajf% 를 날리면 안된다!!!!(풀스캔한다.)

무조건 MATCH AGAINST 문을 사용해야 전문 검색 인덱스를 타고 날아간다.

> 질문 : 이번 프로젝트에서 이 방식을 사용해봐도 될까요? 자주 사용되는 방법인지 모르겠네요

함수기반 인덱스
=

### 가상 컬럼 사용

컬럼 1 : 성

컬럼 2 : 이름

위 두가지 컬럼을 모두 이용해 조회해야하면 fullname이라는 컬럼을 만들어야만했다.

하지만 가상 컬럼을 이용하면 실제 컬럼을 추가하지않고 인덱스만 생성할 수 있다.

### 함수를 이용한 인덱스

CONCAT(first_name,' ',last_name)

처럼 함수를 이용해 인덱스를 생성하는 것이 가능하다.

### 멀티 밸류 인덱스

레코드 1건이 1개의 인덱스 키 값을 갖지만 Json형태의 자료를 배열로 가지게되면 1건의 레코드가 여러개의 인덱스키를 가진다.

InnoDB도 Json형태의 자료를 저장할 수 있고 배열을 저장할 수 있다.

MEMBER OF() JSON_CONTAINS() JSON_OVERLAPS() 함수를 이용하면 멀티 밸류 인덱스를 사용한다.

클러스터링 인덱스
=

클러스터링이란 비슷한 것끼리 같이 묶어놓은 군집화이다.

B-Tree 인덱스도 (프라이머리키가 아닌 세컨더리 인덱스포함) 비슷한 것끼리 같이 묶여있으니 클러스터링 인덱스라고 생각할 수 있다.

하지만 B-Tree 인덱스를 가르키는 말이 아니고 테이블 레코드의 저장된 순서를 의미한다.

실제 테이블 레코드에 저장됐을 때 **프라이머리 키**로 정렬된 경우만 클러스터링 인덱스라 한다.

>세컨더리 인덱스를 생성해도 테이블 레코드가 정렬되는 것이아니라 B-Tree가 정렬되는 것임

특이한 것은 세컨더리 인덱스의 경우 리프노드는 인덱스 키와 주소를 가지지만 클러스터링 인덱스의 경우 **모든 데이터를 다 가진다.**

세컨더리 인덱스에 미치는 영향
=

InnoDB는 세컨더리 인덱스가 레코드의 고유주소(ROWID)를 가지지 않는다.

그 이유는 프라이머리키를 이용한 클러스터링인덱스에 있다.

클러스터링인덱스는 테이블의 실제 위치를 계속해서 정렬한다. 즉 ROWID를 사용하면 실제 주소가 계속해서 바뀐다는 의미다.

그렇게되면 세컨더리 인덱스의 주소값이 계속해서 바뀌기때문에 비효율적이다.

**그래서 세컨더리 인덱스는 프라이머리키를 논리적주소를 가진다.**

클러스터링 인덱스의 장단점
=

우선 프라이머리키로 범위 검색을 할 때 매우 빠르다.
> 매번 테이블의 실제 레코드를 정렬하기때문

세컨더리 키가 프라이머리키를 가지기때문에 인덱스만으로(인덱스 커버링) 처리될 수 있는 경우가 많다.

클러스터링 키가 크면 인덱스의 크기가 커지는 단점

세컨더리인덱스의 경우 프라이머리키로 다시 탐색해야하는 단점(테이블의 레코드 중 인덱스를 제외한 컬럼을 조회하는 경우)

INSERT 시 정렬해야하기때문에 성능이 느림(맨 마지막에 넣지않음)

### 프라이머리 키 크기

프라이머리 키가 커지면 세컨더리 키 인덱스 또한 커진다.(주의)

### 유니크 인덱스 vs 일반 세컨더리 인덱스

둘 다 인덱스 자체의 특성은 똑같다.

처리 속도가 세컨더리가 느리지만 그 이유는 인덱스 특성이 달라서가아니고 중복데이터때문에 읽어야할 양이 많기때문이다.

결코 성능상 차이는 없다.

**그저 많이 읽어야해서 느릴뿐(CPU가 수행하는 컬럼비교는 성능에 영향이 거의없다)**

### 유니크 인덱스의 쓰기

유니크 인덱스는 체인지 버퍼를 사용할 수 없다.

즉 버퍼에 모았다가 처리가 불가능하고 매번 중복 체크를해야한다.

>질문 : p278 이름같은 컬럼에도 유니크인덱스를 걸 수 있는가? 기본적으로 중복되지않나?

외래키 특징
=

FK 제약조건이 걸려있다는 가정을 해보자.

부모테이블에서 특정 행을 쓰기잠금을 획득하고 자식 테이블에서 그 행에대한 FK를 사용하려하면 기다려야한다.
즉 자식테이블에서 외래키를 사용한 변경은 부모테이블의 허락을 받아야한다.

자식 테이블이 먼저 쓰기 잠금을 걸었다면 부모테이블이 기다려야할 수도 있다.

DELETE CASCADE가 걸려있다면 부모 레코드가 삭제되면 자식 레코드도 삭제되야하기때문이다.


