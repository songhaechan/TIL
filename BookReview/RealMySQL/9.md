풀 테이블 스캔 & 풀 인덱스 스캔
=

풀 인덱스 스캔은 조회대상이 인덱스 컬럼인 경우 실행된다.

풀 테이블 스캔은 기본적으로 하나하나 레코드를 읽는다.

아래와 같은 조건에서 주로 풀 테이블 스캔이 실행된다.

- 테이블의 레코드 건수가 작을 때
- WHERE 이나 ON 절에 인덱스를 사용하지 않을 때
- 인덱스 레인지 스캔을 사용하더라도(BETWEEN) 그 건수가 너무 많을 떄

### 테이블의 데이터가 너무 많은데 풀 테이블 스캔을 해야할 때

이 경우 InnoDB는 연속된 데이터 페이지가 읽히고 그 양이 매우 많을 때 백그라운드 스레드가 읽어올 페이지 수를 계속 증가시켜 버퍼풀에 저장해둔다.

> 그래서 풀 테이블 스캔이 그렇게 느리지 않는 이유다.
>
> 이 방식은 리드 어헤드 라고 한다.
>
> 리드 어헤드는 포그라운드 스레드가 페이지를 읽어오다 특정 시점이되면 백그라운드 스레드가 페이지를 읽어오는 것을 뜻한다.

### SELECT COUNT(*) FROM employees;의 실행계획은?

모든 레코드를 조회하기때문에 **풀 테이블 스캔**을 이용할 거라고 예상하기 쉽다.

하지만 **풀 인덱스 스캔**을 사용할 가능성이 높다.

레코드의 다른 컬럼을 조회하는 것이아니라 레코드의 개수만 필요하기때문이다.

### 하나의 쿼리를 여러 스레드가 작업을 동시에 나눠서 처리가 가능하다. 단 단순히 테이블의 전체 건수를 가져오는 쿼리만

## ORDER BY

정렬은 인덱스를 사용하는 것과 인덱스를 사용하지않는 Filesort로 나뉜다.

Filesort는 인덱스가 필요없기때문에 select를 제외한 쿼리의 성능은 올라가지만 많은 레코드를 읽는다면 모두 **메모리에 올려 정렬**해야해서 성능이 떨어진다.

## 소트 버퍼

정렬대상이 소량이면 문제는 없다.

하지만 대량이라면 모두 메모리에 올려 정렬처리를 하기엔 무리가 있다.

> 소트 버퍼는 세션 메모리 영역으로 동적으로 할당되는 영역이라서 그렇다. 요청이 많다면 그만큼 메모리 부족현상을 겪을 수 있다.

그래서 소트 버퍼의 공간을 정하고 그 공간만큼 정렬하고 **디스크에 임시저장 한다.**

즉 인덱스를 사용하지않는 정렬은 디스크I/O가 빈번히 발생한다.

## 정렬 알고리즘

### 싱글 패스 정렬

SELECT 대상에 인덱스 칼럼을 제외한 다른 컬럼이 있는 경우 이 컬럼까지 모두 메모리에 올려서 정렬을 수행한다.

> 물론 이 방식도 소트버퍼, 멀티 머지를 이용한다.
>
> 멀티 머지는 임시디스크에 정렬된 결과를 새로운 정렬결과와 병합하는 작업을 의미한다.

### 투 패스 정렬

SELECT 대상에 정렬대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬한다.

정렬 후 프라이머리키를 가지고 다시 조회한다.

    여기서 두 정렬 방식의 장단점이 나온다.

    투패스는 조회가 2번 이루어지지만 메모리에 퍼 올리는 데이터가 적다.

    싱글 패스 정렬은 조회는 1번에 하지만 그만큼 메모리에 퍼 올리는 데이터가 많다.

이런 이유로 BLOB나 TEXT 타입은 투 패스 정렬을 이용한다.

기본적으로 InnoDB는 싱글 패스를 적용한다.

> 이렇기때문에 SELECT문에서 *로 조회하는 것은 비효율적인 쿼리를 작성하는 것이다. 꼭 필요한 컬럼만 조회하자. 소트버퍼가 힘들어한다...(Filesort를 사용할 경우)

## 정렬 처리 방법

우선 가장 좋은건 Filesort를 사용하지않는 인덱스 방식이 가장 빠르다.

그 다음으로 조인에서 드라이빙 테이블만 정렬 그다음은 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 순으로 느려진다.

>드라이빙 테이블은 조인 시 기준이 되는 테이블을 말한다. 그 반대는 드리븐 테이블이다.

### 조인의 드라이빙 테이블만 정렬

조인 이전에 미리 드라이빙 테이블을 정렬하고 드리븐테이블과 조인한다.

조건은 단순하다. 드라이빙 테이블의 컬럼만으로 ORDER BY절을 작성하면된다.

### 임시 테이블을 이용한 정렬

ORDER BY 절에 드리븐 테이블의 컬럼을 사용하면 무조건 임시 테이블을 만들고 조인 후 정렬을 수행한다.

## 인덱스를 사용하지 못하는 정렬(filesort)는 왜 느릴까?

정답은 인덱스를 사용하지않는 정렬은 **버퍼링** 방식이기때문이다.

### 스트리밍 방식

조건에 일치하는 결과를 바로바로 사용자에게 전달한다.

즉 제일 첫 레코드를 받는 응답시간이 매우짧다.

이 것은 인덱스를 사용하는 정렬에만 사용하는 방식이다.

이 방식은 LIMIT을 사용하면 쿼리 실행 시간을 줄일 수 있다.

### 버퍼링 방식

인덱스를 사용하지 않고 ORDER BY를 사용하면

우선 디스크의 데이터를 메모리로 퍼올린다.

그 후에 정렬을 수행한다.

즉 스트리밍은 이미 정렬돼있기때문에 메모리로 올리는 즉각 반환하지만 버퍼링은 정렬돼있지않기때문에 데이터를 모두 퍼올리고 정렬을 수행해야한다.

그래서 버퍼링 방식(인덱스를 사용하지않는 ORDER BY)는 LIMIT을 사용한다해도 별다른 성능 향상이 없다.

> 어차피 다 퍼올려야하기때문

    하지만 JDBC는 내부에 버퍼가 있어서 스트리밍 방식이라 하더라도 데이터가 모두 올라와야 사용자에게 반환한다.

    네트워크 비용때문에 이런 방식을 채택했고 스트리밍으로 변경이 가능하긴하다.

## GROUP BY

GROUP BY도 스트리밍처리를 할 수 없게 만드는 쿼리다.

인덱스를 사용한다면 

차례로 인덱스를 읽는 인덱스 스캔(타이트 스캔)

인덱스를 건너뛰는 루스 인덱스 스캔

을 사용한다.

인덱스를 사용하지않으면 임시테이블을 사용한다.

### 타이트 스캔

GROUP BY 칼럼에 인덱스가 와야한다.

또한 드라이빙 테이블에 속한 컬럼만을 이용해 그룹핑해야한다.

### 루스 인덱스 스캔

단일 테이블에 수행되는 GROUP BT cjfldpaks tkdydgksek.

### 임시테이블 사용

인덱스를 전혀 사용하지않으면 이 방식으로 처리한다.

인덱스를 사용하지않으면 InnoDB는 내부적으로 GROUP BY 컬럼들을 유니크 인덱스로하는 임시 테이블을 생성한다.

별도의 정렬없이 처리한다.

## DISTINCT

SELECT DISTINCT는 GROUP BY와 정확히 동일한 방식으로 처리된다.

> 주의해야할 점은 DISTINCT는 레코드를 유니크하게 SELECT하는 것이지 컬럼을 유니크하게 SELECT하지않는다.

## 집합함수 + DISTINCT

SELECT COUNT(DISTINCT s.salary)

위에서 DISTINCT는 레코드를 유니크하게 가져온다고했다.

하지만 집함함수와 같이 사용된 DISTINCT는 인자로 전달된 컬럼만 유니크하게 가져온다.

**또한 임시테이블을 이용한다.**

임시테이블을 만들 때 인자로 전달된 컬럼을 유니크인덱스로 생성하는 임시테이블을 만들기때문에 그 데이터가 많다면 성능이 느려질 수 밖에 없다.

하지만 DISTINCT에 인덱스 컬럼을 사용하면 인덱스를 사용해 스캔하게된다.

## 고급 최적화

실행 계획 = 통계 정보 + 옵티마이저 옵션 이다.

다시 옵티마이저 옵션은

조인 관련 옵션 + 스위치 옵션 이다.

스위치 옵션을 알아보자

> 시스템 변수를 default, on, off 로 나눈다.

### MRR 과 배치 키 액세스

드라이빙테이블에서 레코드를 읽고 드리븐 테이블에서 일치하는 레코드를 찾아 조인한다. - **네스티드 루프 조인**

하지만 !

조인 처리는 MySQL엔진이 처리한다. 즉 스토리지엔진은 조인에대해 최적화가 불가능했다.

하지만 !

이 단점을 보완하기위해 **버퍼링을 도입했다.**

드라이빙테이블에서 데이터를 읽어 **조인버퍼에** 넣고 버퍼가 가득찰 때 드리븐테이블에서 레코드를 읽어 **조인**한다.

이러한 방식을 MRR이라한다.

MRR을 응용해서 조인하는 방식을 **BKA조인이라한다**.

> BKA조인은 기본 비활성화임. 부가 정렬작업때문에 비효율적일 수 있음

### 블록 네스티드 루프 조인

네스티드 루프 조인과 달리 블록 네스티드 루프 조인은 **조인 버퍼**를 사용한다.

또 다른 차이점은 **조인 순서이다**

첫 번째 WHERE문의 조건을 찾아서 **버퍼에 저장**

두 번째 WHERE문의 조건을 찾아서 조인버퍼에서 꺼내 조인한다.

**즉, 두 번째 조건에 맞춰 조인하게된다.**

> 정렬 순서가 흐트러질 수 있음에 주의해야한다. 드리븐테이블에 맞춰 정렬된다.

### 인덱스 컨디션 푸시다운

우선 디폴트값이 ON이다.

OFF인 경우

WHERE last_name='Action' AND first_name LIKE %sal;

그리고 인덱스는 (last_name first_name)으로 생성돼있다.

쿼리는 last_name을 먼저 읽고 first_name에 해당하는 레코드를 테이블에서 직접 읽어서 가져온다.

> 필요없는 레코드까지 직접 테이블에서 읽으려고한다.

하지만 ON으로 설정하면

first_name에 해당하는 컬럼을 스토리지엔진이 알 수 있게 MySQL엔진이 알려주고 불필요한 레코드는 접근하지않는다.

> 필요없는 레코드는 직접 접근하지않는다.

### 인덱스 확장

세컨더리 인덱스는 프라이머리키를 항상 가지고있다고 했다.

다시말하면 세컨더리 인덱스는 프라이머리키를 같이 가지는 인덱스이다.

원래는 옵티마이저가 이를 사용하지않았지만, 요즘은 세컨더리 인덱스에 프라이머리키가 같이 생성된 것처럼 실행계획을 수립한다.

## 인덱스 머지

보통 테이블당 하나의 인덱스를 사용하지만 인덱스 머지는 2개 이상의 인덱스를 이용해 쿼리를 처리한다.

### 인덱스 머지 - 교집합

각 인덱스를 따로 검색하고 검색결과의 교집합을 반환한다.

물론 하나의 인덱스를 이용하는게 효율적이라 판단하면 인덱스 머지를 사용하지않는다.

### 인덱스 머지 - 합집합

WHERE에 OR문을 사용하면 2개 이상의 인덱스를 사용할 수 있다.

똑같이 각각을 검색하고 그대로 합친 결과를 반환한다.

합집합의 특성은 교집합이 있다는 것이고 이것은 중복데이터를 의미한다.

하지만 인덱스 머지 합집합은 각각의 검색이 프라이머리 키로 정렬돼있어서 프라이머리키가 중복인 레코드는 제거하고 반환한다.

### 인덱스 머지 - 정렬 후 합집합

인덱스 머지 합집합은 프라이머리키로 정렬돼있기때문에 정렬이 따로 필요치않다.

하지만 반드시 위와같은 경우만 있지는 않다.

그런 경우엔 Using sort_union이라는 메세지를 Extra에 출력한다.

이 경우는 각 집합을 프라이머리키로 정렬하고 중복을 제거한다.

## 세미 조인

세미 조인은 실제 조인은 실행하지않고 다른 테이블에 조건에 일치하는 코드가 있는지 확인하는 쿼리다.

```sql
select * from emplotees e
where e.emp_no IN
(select de.emp_no from dept_emp de where de.from_date='1999-03-22')
```

위와 같은 서브쿼리가 포함된 경우다.

예전의 방식은 우선 본 쿼리를 풀스캔하고 서브쿼리와 일치하는지 비교한다.(매우 비효율적)

### 테이블 풀-아웃

세미조인을 최적화하는 전략이다.

기존에 서브쿼리를 (IN절) 아우터 쿼리(JOIN으로)꺼내는 방식이다.(자동으로 해준다.)

Extra에 따로 표시되지는 않는다.다만 id컬럼의 값이 같다는 것으로 테이블 풀-아웃이 실행됐음을 알 수 있다.

### 퍼스트 매치

퍼스트 매치도 세미조인을 최적화한다.

IN형태를 EXISTS(subquery)형태로 튜닝한다.

즉, JOIN을 이용해 처리되고 (실제로 id컬럼이 똑같다) 일치하는 레코드 1건만 찾으면 바로 반환한다.

### 루스 스캔

루스 스캔도 세미조인을 최적화한다.

모든 인덱스를 탐색하지않고 유니크한 인덱스 한 건만 읽고 반환한다.(어차피 결과가 같기때문에)

### 구체화

구체화는 내부 임시 테이블을 생성해서 서브쿼리를 통체로 구체화했다는 것을 의미한다.

### 중복 제거



