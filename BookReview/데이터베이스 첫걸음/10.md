10장 트랜잭션과 동시성 제어
=

## 트랜잭션이란 복수 쿼리를 하나의 단위로 묶은 것을 말한다.

### - 계좌 이체 예시

계좌이체라는 하나의 작업단위는 아래와 같을 것이다.

1. A에서 출금 -> 2. 이체대상 탐색 -> 3. B에게 입금

1번 쿼리를 실행했지만 2번에서 오류가 발생했다고 가정해보자.

DB에서 A의 잔고를 감소시켰지만 2에서 문제가 생겨 그대로 중단됐다면 어떤 일이 벌어질까?

돈은 빠져나갔지만 B에게는 입금이되지않는 아주 큰 문제가 발생한다.

이런 문제를 방지하기위해 위 과정을 하나의 트랜잭션이라는 작업단위로 묶고 **ACID** 라는 특성을 만족시켜야한다.

## ACID

### - 원자성
**하나의 트랜잭션이 전부 성공할지 전부 실패할지를 보증하는 구조**

위 예시에서 반성공 반실패라는 개념은 존재해서는 안된다.

이체 대상을 탐색하던 중에 문제가 발생하더라도 A에게서 출금이됐다면 원상태로 복구해야한다.

이를 **RollBack** 이라고한다.

전부 성공한다면 Commit(확정)을하고 중간에 실패한다면 Rollback을 통해 전부 실패 전부 성공을 보증한다.

### - 일관성

**일련의 데이터 조작 전후에 그 상태를 유지하는 것을 보증하는 구조**

말이 좀 어려운데 사용자의 데이터 삽입에 고유번호를 부여해 순차적으로 증가해야한다는 상태가있다고 생각해보자.

이 상태는 동시에 데이터삽입이 이루어지더라도 중복번호 없이 그 상태(순차적으로 증가하는 고유번호)를 유지해야한다는 것이다.

### - 고립성

**데이터 조작을 복수 사용자가 동시에 실행해도 모순없이 실행되는 것을 보증하는 구조**

사용자 A와 사용자 B는 호텔 예약을 하려한다.

빈 방의 수는 10개이고 동시에 접근해 조회하고 빈 방을 업데이트 할 것이다.

A 빈방 조회 -> 10개
B 빈방 조회 -> 10개
A 예약 후 빈 방 감소 -> 9개
B 예약 후 빈 방 감소 -> 9개

방은 2개가 줄어야한다. 하지만 동시에 접근했고 동시성에대한 제어가 없다면 위처럼 기대한 결과가 나올 수 없다.

이 때 사용하는 것이 **잠금**이다.

사용자 A가 내 작업(트랜잭션)이 완료되기전까진 나의 행에는 누구도 들어올 수 없어. (Select ~ FOR UPDATE)

그렇다면 B는 A의 작업이 끝나야지만 작업을 시작할 수 있다.

여기서 중요한 것은 어느정도로 잠금을 유연하게 혹은 단단하게 하는지 여부이다.

### 격리수준 완화에따른 현상

- 더티 읽기 (Dirty Read)

    트랜잭션이 커밋되기 전에 다른 트랜잭션에서 데이터를 읽을 수 있는 현상 A가 빈방을 9로 감소시키고 커밋을 하지않았더라도 B의 트랜잭션에선 9로 읽힌다.

- 애매한 읽기 (NonRepeatable Read)

    트랜잭션이 커밋을하면 조회의 결과가 달라진다. 위 더티읽기와의 차이는 커밋을 했느냐 하지않았느냐의 차이이다. 더티 읽기보다는 격리수준이 조금 더 높다고 볼 수 있다.

- 팬텀 읽기 (Phantom Read)

    범위 읽기에서 한 행의 추가나 삭제가 그대로 반영된다.

### - 지속성

장애가 발생해도 지금껏 기록한 로그기록으로 항상 복구시킬 수 있는 구조를 말한다.

11장
=
## 타 트랜잭션의 갱신은 자신의 트랜잭션 읽기에서 어떻게 보이는가?

트랜잭션 A와 B를 가정하자.

그리고 현재 t1테이블에는 1 MySQL 한 행이 존재한다.

A와 B는 start transaction으로 작업을 수행한다.

먼저 A가 select * from t1으로 조회했고 1 MySQL을 읽었다.

후에 B가 2 Oracle을 추가했고 커밋하지않았다.

다시 A가 조회를 하면 똑같이 1 MySQL이 조회된다.

그럼 B가 커밋을 한다면?

똑같이 A는 1 MySQL이 조회된다.

즉 MySQL의 기본 격리수준은 반복 읽기로 설정되어있다는 뜻이다.

### B의 트랜잭션에서 갱신을하고 커밋을 하던 하지않던 상관없이 A는 조회결과가 처음 조회와 같아야하는 반복읽기를 지원한다. 즉 더티 읽기(커밋하지않은 데이터 갱신이 조회에 영향을 미침)와 애매한 읽기(커밋한 데이터 갱신이 조회에 영향을 미침)가 반복읽기에는 해당하지않는다.

### 즉 !! A의 트랜잭션이 끝나기전까지는 A의 첫 조회결과가 절대 변경되지않는다.

## 격리 수준의 변화를 줘볼까?

그렇다면 A의 격리수준을 디폴트값 반복읽기가 아닌 커밋된 읽기로 변경해보자.

커밋된 읽기는 반복읽기와 다르게 애매한 읽기현상이 발생한다.

### 즉 이전 반복읽기는 커밋이 되던 되지않던 조회는 항상 같아야했지만 커밋된 읽기의 경우에는 커밋이 되지않았을땐 항상 같지만 커밋한 경우에는 조회가 달라진다.

## MVCC 기술

1. 읽기 수행시 갱신중이라도 블록되지않는다.

    블록되지않는다는말은 조회자체는 가능한 것을 말한다.
    밑에 2번과 같이 생각해보는게 좋다.

2. 블록이 되지않는다고 조회의 내용이 달라지지않는다는 것은 아니다. 격리 수준에 따라 내용이 바뀌는 경우가 있다.(앞서 커밋된 읽기와 반복읽기)

3. 갱신 시 배타적 잠금을 얻는다.
    
    한 트랜잭션이 갱신을 시도하면 다른 트랜잭션은 조회는 가능하지만 나머지 작업은 수행이 불가능하다.
    잠금하는 행의 범위는 격리수준마다 상이함

4. 갱신과 갱신은 나중에 온 트랜잭션이 잠금을 획득하려고 할때 블록된다.
    
    당연하다.

5. 갱신 전의 데이터를 UNDO 로그로 남긴다. 

    용도는 롤백 수행시 원본 데이터를 복구하기위해서이고, 격리 수준에따른 조회데이터를 제공하기위함이다.

12장 잠금 타임아웃과 교착 상태를 시험하자
=

이번에도 Transaction A, Transaction B 를 가지고 시험해보자.

## 먼저 잠금 타임아웃 상태

A의 잠금 타임아웃은 5초로 설정

A와B 트랜잭션 시작

B가 id=4에 데이터 Insert

A도 id=4에 데이터 Insert

A는 5초를 기다린다.

5초가 지나도 잠금이 풀리지않으면(B가 rollback을 하거나 commit을 하지않으면) A에서 오류가 난 쿼리는 롤백된다.

### MySQL은 잠금타임아웃으로 발생한 오류는 트랜잭션 전체를 롤백하지않고 오류가 난 쿼리만 롤백한다.

## 교착상태 시험

똑같이 Transaction A와 Transaction B가 경합한다.

테이블a와 b를 생성한다.

트랜잭션 A와B를 시작한다.

A는 a테이블 1번행에 Firebird insert

B는 b테이블 1번행에 MySQL insert

이때 A가 b테이블 1번행에 Firebird insert를 시도하고

B가 a테이블 1번행에 MySQL insert를 시도한다면 어떻게될까?

DBMS는 이를 교착상태라고 파악한다.(Dead Lock)

DBMS는 교착상태가 발생하고 영향이 적은 트랜잭션을 트랜잭션단위로 롤백하는데 결과는 아래와 같다.

테이블 a 1행 Firebird

테이블 b 1행 Firebird

결과적으로 트랜잭션 B가 전체 롤백되고 A의 상태만 반영되었다.

### 추가적으로 MySQL은 기본 select에는 잠금을 걸지않는다. 하지만 select for update를 통해 잠금을 걸 수는 있다. 또한 Insert경우 인서트 인텐션 락을 지원하는데 서로 충돌하는 값이 아닌 이상 락을 걸지않는다.

## DBMS 전반적 대책

- 트랜잭션을 자주 커밋

    트랜잭션을 자주 커밋하면 잠금을 자주 푼다는 말과 같다.

- 테이블에 락을 걸었다면 정해진 순서로 테이블에 접근하고 행에 락을 걸었다면 정해진 순서로 행에 접근시킨다.

    순서없이 트랜잭션을 접근시키면 교착상태는 당연히 발생하기 쉽다.(위 예시)

- 되도록 읽기잠금획득은 피한다.

- 테이블 잠금보다는 행 잠금을 사용하자(할 수 있다면) 격리수준은 되도록 커밋된 읽기로 한다.

- 5번 전체적으로 이해가 안됨

- 6번 인덱스가 무엇인지 모르겠음 (PK인가..?) PK가 있는데 굳이 인덱스를 사용하는 이유를 찾아봐도 모르겠음

## 하지말아야할 트랜잭션 처리

- 오토커밋 

    오토커밋은 쿼리 단위로 커밋하는 설정이다. 이는 커밋에대한 부하를 높이기때문에 적절한 단위의 트랜잭션으로 처리해야한다.

- 긴 트랜잭션

    위에서 언급한 오토커밋은 가장 작은 단위의 트랜잭션이라 볼 수 있지만 긴 트랜잭션도 잠금과 블록으로인해 교착상태를 발생시키기 쉬움으로 주의해야한다.

    - 대량 처리를 한 개의 트랜잭션이 실행한다.

        UNDO로그를 생각해보자. 트랜잭션이 지속되는한 그리고 쿼리가 계속해서 실행된다면 rollback할 log가 계속해서 쌓이게된다. 이런 쓸때없이 큰 로그를 남기지않기위해선 적당한 크기로 트랜잭션을 분리해야한다.

    - 아무것도 하지 않는 트랜잭션 유의

        select를 한 번 실행하고 트랜잭션을 계속 열어놓는다면 반복 읽기를 유지하기위해 UNDO로그가 계속 유지된다.

    - 대화처리

        사용자의 처리를 기다려야하는 (매우 긴 시간) 쿼리는 시스템 전체의 효율을 감소시킨다.

    - 능력 밖의 트랜잭션 '수'

        놀이공원 입장객 수를 상한선없이 수용한다면 이용객들사이에서 교착,타임아웃 상태가 많이 발생한다. DB도 이와 같이 상한선을 정하지않으면 많은 수의 트랜잭션이 경합하게되므로 주의해야한다.

    