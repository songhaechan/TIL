성능
=

## 성능을 측정하는 2가지 지표

- 처리 시간 : 처리하는데 소요된 시간

- 응답 시간 : 사용자가 요청한 후 응답이 돌아오기까지의 시간

- 처리율 : TPS(Transaction Per Second) 트랜잭션의 초당 처리건수를 말한다. 50TPS는 초당 50건의 트랜잭션을 처리했음을 의미한다.

## 정점과 한계점

특정 시간 혹은 기간에 사용자가 동시에 몰리는 경우가 있다.

이벤트기간엔 사용자가 몰릴것이 예상되고 트랜잭션의 처리량은 늘어날 것이 확실하다.

이때 어느정도 수준까지는 트랜잭션처리가 원활하게 이루어지다가 응답시간이 비약적으로 증가하게되는 point가 존재하는데 이러한 특이점을 한계점이라하고 병목현상이라한다.

## 성능을 결정하는 요인

### 사용자가 요청을 하고 응답이 돌아올 때까지 DB에서는 어떤 일이 일어날까?

1. DB는 SQL문을 받으면 Parse로 구문오류를 점검한다.

    - 구문오류 시 에러메세지를 출력

2. 구문오류를 통과했다면 DB는 실행계획을 세운다.

    해당 SQL문을 처리하기위해 데이터에 어떤 경로로 접근할 것인지 계획을 세운다. 이 **실행계획**은 개발자가 세우지않는다. DB내부의 **옵티마이저**가 결정한다.

    그렇다면 옵티마이저는 어떤 기준으로 최적의 접근법(실행계획)을 세울까?

    테이블의 행과열의 수, 열의 길이와 데이터형, 테이블 크기, 기본키와 제약정보, 분산과 편향 이라는 통계정보를 토대로 옵티마이저는 실행계획을 세운다.

    show table status; 를 입력하면 위에서 언급한 통계정보를 확인할 수 있다.

3. **옵티마이저의 실행계획 방법(중요)**

    옵티마이저가 어떤 기준으로 데이터에 접근하는지를 알아야 SQL문의 성능에대해 파악할 수 있다.

    EXPLAIN ~ SQL문 을 입력하면 해당 SQL문의 실행계획을 볼 수 있다.

    중요한 컬럼들을 살펴보자.

    column : type  : ALL or range

    ALL은 말그대로 전체를 순차적으로 선형탐색한다. range는 범위탐색을 하기때문에 당연히 ALL보다는 성능이 좋다.

    range는 SQL문 중에 where문이 존재해야 탐색방법으로 선택한다. **하지만 제일 중요한 것은 where문이라고 모두 range를 선택하지않고 인덱스를 사용해야만 선택한다.** (기본키는 인덱스다)

    다음은 possible_keys 열과 key 열이다.

    where문의 조건에 기본키를 사용해 탐색한다면 EXPLAIN문에는 두 열의 값은 PRIMARY가 된다.

    이 의미는 인덱스의 이름이자 인덱스를 사용한다는 의미다.(기본키는 인덱스이고 일반열들은 인덱스가아니다.)

    show index from table_name; 쿼리를 날리면 해당 테이블의 인덱스를 볼 수 있다.

    **위에서 언급했지만 where문에 기본키가 아닌 인덱스를 지정하지않은 열을 기준으로 탐색하면 range탐색이 아닌 all탐색을 한다.**

    기본키가 아닌 열도 인덱스로 지정해서 탐색을 효율적으로 할 수 있다. (CREATE INDEX 인덱스명 ON 테이블명)

    이제 인덱스가 가지는 장점은 정확하게 알아봤다. 당연히 인덱스를 활용하면 성능이 높아지기때문에 때론 매우 극적인 효과까지 기대할 수 있다.

## 인덱스의 구조

인덱스는 성능 튜닝의 제 1 선택으로 자리잡았다.

그렇다면 도대체 왜 인덱스가 DB의 성능을 향상시키는지 알아보자.

SHOW INDEX FROM 테이블명;으로 Index_type열을 살펴보면 BTREE란 키워드를 볼 수있다.

BTREE는 이진트리와 달리 자식노드가 2개이상 일 수 있다. 또 한 노드에 데이터가 2개 이상일 수 있다. 2개라면 2차 B-TREE 3개라면 3차 B-TREE라 한다.

노드의 데이터 수가 2개라면 자식노드는 3개가 된다.

즉 한 노드의 데이터수가 n이라면 자식노드는 n+1이 된다.

또 한 노드의 데이터는 정렬된 상태여야한다.

그리고 이진트리와 비슷하게 루트노드의 대소를 비교해 작으면 왼쪽 크면 오른쪽으로 생성한다. 그 가운데는 적절한 정렬을 통해 배치한다.

BTREE의 시간 복잡도는 log스케일로 컴퓨터공학에서 매우 좋아하는 스케일을 가진다.

## 인덱스는 무조건 좋은가?

극단적으로 모든 열에 인덱스를 생성한다면 어떨까?

탐색에는 매우 빠를것이다. 하지만 데이터를 추가하거나 삭제한다면 인덱스도 그만큼 변동이 있어야한다.

이를 인덱스 갱신이라하는데 데이터의 변형이 일어나면 또 인덱스가 많은 열에 생성되어있다면 인덱스를 갱신하는데 드는 시간이 많을 것이다.

첫 장에서 나온 트레이드오프관계가 이 곳에서도 발생한다.

탐색을 위해 인덱싱을 하면 할 수록 삽입/삭제에는 그만큼 느려진다.

적절한 구간을 찾아야함을 알 수 있다.

    