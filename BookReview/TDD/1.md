들어가기
=
테스트 주도 개발은 기존의 아키텍처 주도 개발과는 완전히 다른 모습을 가지고 있다.

정말 작은 단위 테스트로부터 코드가 확장되어나가는데 여기서 핵심은 테스트를 통과한 코드들만이 반영된다는 것이다.

작은 기능부터 어떻게 거대한 프로젝트를 만들어나가는지 사실 감조차 잡히지않는다.

하지만 한 가지 명확한 사실은 있다. 작은 기능을 테스트하는 과정(실패하는 테스트를 작성하고 하나씩 하나씩 중복을 제거하며 리팩토링하는 과정)은 프로그래밍을 하며 용기를 준다.

반영된 코드들이 문제를 일이키지않을 것이란 확신을 주는것이다.

그러한 확신은 쉽게 얻을 수는 없다. 엮은이도 테스트 주도 개발은 단숨에 얻어질 수가 없다고 했다. 수많은 좌절과 실패를 겪고 (수파리)일어나야 도달할 수 있다고 한다. 

읽다보니 정말 무술을 연마하는것 같은 느낌을준다.

우선 책의 목적은 전체적인 TDD의 리듬을 보여준다. 실패하는 과정부터 하나의 테스트가 성공해나가는 과정을 글로 담았다.

1부의 화폐예제로부터 하나씩 살펴보자.

1부의 1장
=

TDD는 우선 전체를 보지않는다. 당장 앞에 놓인 하나의 단위 기능을 테스트할 뿐이다.

하지만 중요한 것은 이 테스트를 하는 과정이다.

p.47에서 켄트 백이 말하는 TDD의 주기를 그대로 가져와봤다.

1. 작은 테스트를 하나 추가한다.
2. 모든 테스트를 실행해서 테스트가 실패하는 것을 확인한다.
3. 조금 수정한다.
4. 모든 테스트를 실행해서 테스트가 성공하는 것을 확인한다.
5. 중복을 제거하기 위해 리팩토링을 한다.

백 번 보는 것보다 한 번 해보는 것이 최고다 직접 해보자.
-

우선 위에서 언급한 테스트에 앞서 **무엇을 테스트해야하는가**에 초점을 맞춰보자.

상황은 이렇다. 주식 종목의 수에 가격을 곱한 합계를 계산해내는데 기존의 서비스는 **달러**의 계산만 가능했다.

하지만 다른 국가에서 사업하려는 수요덕분에(?) 새로운 기능이 추가되어야한다.

1. 단순하게 금액을 어떤 주식의 수에 곱한 금액을 결과로 얻어야한다.
2. 화폐가 다른 두 금액을 더해 주어진 환율에 맞게 변한 금액을 결과로 얻어야한다.

이렇게 ToDoList를 만들고 하나씩 테스트를 진행하는 것이다.(테스트 주기에 따라서)

가장 단순해보이는 1번부터 테스트해보자 !

```java
public void testMultiplication(){
        Dollar five = new Dollar(5);
        five.times(2);
        assertEquals(10,five.amount);
    }
```
자 우리가 테스트하고싶은 기능은 위 코드다.

이렇게 작성해놓고 보니 five.amout는 public 필드로 선언되어 굉장히 불편하고 문제를 유발할 것만 같다.

이것도 ToDoList에 적어놓자.

## 중요한 것은 최대한 빨리 초록막대(테스트의성공)를 보는 것이다.

하지만 안타깝게도 위 코드는 컴파일조차 되지않는다.

### Dollar 클래스의 부재
### times()의 부재
### amount의 부재
### 생성자의 부재

빨리 초록막대를 보기위해선 테스트가 적어도 수행되도록 필요한 것들을 추가하는 것이다.

```java
public class Dollar {
    int amount;
    Dollar(int amout){
    }
    public void times(int multiplier){
    }
}
```
정말 최소한의 것들만 작성했다.

## 이제 컴파일에러는 나지않는다! 실행시켜보자

![img](/BookReview/TDD/1.png)

프로그래밍을 시작하고 실패했는데 기분이 좋은적은 처음이다.

테스트가 실패했다면 위에서도 말했지만 다시 언급하자면

## 하루빨리 초록막대를 보자!

단순함을 최대치로 끌어올려보자.

```java
int amout = 10;
```
위 코드를 작성한다면 성공할 것이다.

![img](/BookReview/TDD/2.png)

단순함의 극치로 테스트가 성공했다.

자 이제 1-4번 항목을 수행했고 5번 중복을 제거할 차례다.

사실 처음엔 어느 곳이 중복인지 알지 못했고 책에서도 자문하고있다.

**위 사진을 자세히 보면 5와2가 테스트코드에 있다.**

```java
int amount = 10;
// int amount = 5*2 라고 볼 수 있다 !
```

자 이제 테스트코드와 메인코드사이에 중복이 보인다.

5와 2를 제거할 방법은 없지만 위 코드를 times안으로 넣어보자.

```java
public class Dollar {
    //int amount = 10;
    Dollar(int amout){
        amount = 5*2;
    }
    public void times(int multiplier){
    }
}
```

이렇게 작은 단계를 하나하나 거쳐나가는 것이다.

### 이제 상수를 일반화 하자! (변수로 리팩토링)

```java
public void testMultiplication(){
        Dollar five = new Dollar(5);
        five.times(2);
        assertEquals(10,five.amount);
    }
```

5는 생성자로부터 넘어오고있고 2는 times의 파라미터다.

```java
public class Dollar {
    int amount;
    Dollar(int amout){
        this.amount = amount
    }
    public void times(int multiplier){
         amount *= multiplier;
    }
}
```

이제 일반화를 마쳤다. 이렇게 상수로부터 변수로 일반화하는 과정을 거쳐야한다. 작은 단계를 무시하지말자.

이제 TDD의 한 사이클을 경험했다.


