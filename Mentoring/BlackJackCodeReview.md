BlackJack CodeReview
==

1. If문을 쓰되 else를 없애자.

2. main함수는 최대한 간소화하자. (spring controller를 보면 최소한의 메서드만 쓴 걸 볼 수 있다...)

3. 객체의 책임을 분명히하자.

4. 클래스네이밍을 신경쓰자. 

메서드나 필드의 이름은 항상 신경써야한다. 직관적으로 읽혀야하며 해당 네이밍이 정확히 어떤일을 하는지 표현해야한다.

5. 캡슐화를 적용하자. Getter Setter를 이용해 접근하고 수정하자.

캡슐화를 왜 사용해야할까? 

private(protected)로 선언하게되면 다른 클래스의 접근을 허락하지않고 해당 클래스의 멤버를 외부에서 쉽게 바꿀 수가 없다.

이를 정보를 은닉한다고 말하며, 정보의 은닉으로 향후 유지보수나 확장시에 오류를 줄일 수 있다.

6. List타입과 ArrayList타입의 차이점
```java
 List<Card> cardDeck = new ArrayList<>();
 ArrayList<Card> cardDeck = new ArrayList<>();
```

답은 **다형성**이다. 
List는 인터페이스 ArrayList는 클래스다.

List<> = new ArrayList로 선언하게되면 나중에 ArrayList가 아닌 List인터페이스를 구현한 다른 클래스를 선언해줄 수 있기때문에 보다 **유연한**프로그래밍이 가능해진다.


7. git flow를 공부하자. (master, develop, feature)

    #Git폴더에 따로 정리

8. 라이브러리와 프레임워크의 차이점

익숙한 단어들이다. 내가 이제 막 학습을 시작한 Spring은 프레임워크이고, C언어를 공부하며 무심코 사용했던 <stdio.h>에 있는 printf, fopen, puts 등은 C에서 제공하는 기본 라이브러리다.

이들의 차이점은 프로그래밍 제어 흐름에 있다.

C 헤더파일에서 불러와 사용하던 함수들에대한 제어권은 나에게있다. 모든 흐름은 작성자가 설계하지만, Spring 프레임워크에서 제어 흐름은 프레임워크에있다.

그래서 이를 제어의 역전(IoC)이라 한다.

말 그대로 프로그래밍 제어의 책임이 개발자에게서 프레임워크로 넘어가게되고, 그만큼 개발자는 핵심 비지니스로직에 몰두할 수 있게된다.

IoC와 함께 나오는 개념중 DI(의존관계주입)이 있는데, 함께 이해하면 프레임워크에대한 이해가 쉬워질것 같다.

@Controller 나 @Service 애너테이션을 붙여주면 스프링이 올라올때 컴포넌트 스캔을 통해 스프링은 빈으로 객체를 등록하게되고, @Autowired를 이용해 생성자에 인스턴스를 스프링에게 주입받을 수 있다. 이를 DI라 한다.

보통은 객체를 개발자가 직접 생성하고 참조변수에 연결시켜주는 작업이 있어야지만 해당 인스턴스를 사용할 수 있지만, 애너테이션을 붙여줌으로 스프링에게 객체생명주기에대한 권한을 넘겨주게된다.

이처럼 제어의 역전은 제어의 흐름이 개발자에게서 외부환경으로 넘어가는것을 뜻한다.

---

1. Scanner vs BufferedReader

    보통 buffer는 StringBuffer 에서 들어보았지만 BufferedReader에대해선 처음 들어보았다. Scanner와 유사한 기능을 가진 BufferedReader에 대해 알아보자.

    C언어에서 scanf를 사용할 때 버퍼의 기능에대해 알아본적이 있다. 버퍼란 키보드의 입력을 버퍼라는 임시저장소에 모아놓았다가 버퍼가 가득차거나 개행문자를 만나면 프로그램에 한꺼번에 전달하는 방식이다.

    Java에서 Scanner는 1KB의 버퍼를 갖고 BufferedReader는 8KB의 버퍼를 갖는다. 당연하겠지만 8K를 한꺼번에 모아서 전송하는 방식과 1K를 모아서 전송하는 방식에는 **성능의 차이** 가 있을 수 밖에 없다. 

    추가적으로 Scanner는 내부에서 정규표현식적용, 파싱과정 등 여러 과정을 거치기때문에 성능이 더 느리다.

    자료에따르면 Scanner와 BufferedReader의 차이는 꽤나 크다.
    Scanner가 4.8초가 걸리는 일을 BufferedReader는 0.6초걸린다.

    Scanner와 달리 BufferedReader는 입력된 데이터형식이 String으로 고정이므로 데이터를 따로 가공해주어야한다. 추가로 예외처리가 필수적이다.

    PS할 때 scanner를 사용하면 문제를 제한시간 내에 못 푼다고한다. 현재 BlackJack 프로젝트에서는 정수하나를 입력받기때문에 큰 차이는 없겠지만 입력데이터가 늘어날 경우에는 BufferedReader를 고려하자.

2. 접근제어자

    접근제어자의 종류
        
        private protected default public

    1. 
        private은 범위가 가장 좁은 접근제어자로 해당 클래스내에서만 사용할 수 있고 클래스 밖에서는 사용 불가능하다. 메서드,클래스,필드에 붙을 수 있다.

        하지만 최상위 클래스에는 붙을 수 없고 내부클래스에 붙어서 외부에서 내부클래스에 접근할 수 없게 만든다.

    2. 
        protected는 동일한 패키지의 클래스 혹은 해당 클래스를 상속받은 다른 패키지의 클래스들이 접근가능하다.

    3. 
        default는 아무런 접근제어자를 명시하지 않았을때의 상태이고, 동일한 패키지내에서만 접근이 가능하다.

    4. 
        public은 가장 넓은 접근제어자로 어디서든 접근이 가능하다.
    
3. JVM과 메모리구조

    멘토님께서 static필드와 일반필드의 차이점을 고민해보라고 하셨다. 어느곳에 저장되는지를 알기위해 java의 메모리구조에대해 알아보는중에 메모리구조를 알기위해 **JVM(Java Virtual Merchine)** 에대해 먼저 알아보았다.

    자바의 정석 첫 페이지에 Java의 슬로건이 적혀있다.

        Write Once, Run Anywhere

    한 번 프로그래밍한 것은 어느 플랫폼에서도 실행된다.(멋있는 말이다.)

    Java는 OS에 종속적이지 않다. 더 정확히는 JVM이 있는 OS에서는 종속적이지않다.

    우리가 흔히 작성하는 .java파일은 JVM이 인식할 수 있는 .class파일로 컴파일된다.

    즉 JavaCompiler는 .java를 JavaByteCode로 .class파일로 변환해준다.

    .class파일은 JVM위에 올라가 OS가 인식할 수 있는 기계어로 다시 변환하여 OS(cpu)가 인식할 수 있게된다. (JIT Compiler)

    ![img](./jvm.png)

    JVM의 내부 구조는 위 그림과 같다.

    **Class Loader** 는 .class 파일을 로드하고 링크하는 역할을 한다.
    런타임시에 새로운 클래스를 동적으로 로드하고 링크해준다.

    **Excution** 은 클래스를 실행시킨다. 다시 말해 .class파일을 클래스로더가 **Runtime Data Area**에 올려주면 위에 언급한 JIT컴파일러가 (JavaByteCode를)기계어로 번역해준다. 많이 들어보았던 GC도 보인다. GC는 사용하지않는 메모리를 수거해준다.

    자 이제 드디어 static과 non-static을 알아볼 수 있게됐다.

    ![img](./rda.png)

    앞서 설명한 클래스로더가 .class파일을 탐색하는중에 static키워드를 보는 순간 바로 MethodArea에 할당한다.
    MethodArea는 논리적으로 HeapArea이다.

    MethodsArea에는 클래스로더가 적재한 클래스의 모든 메타정보들이 올라간다. (이 때 static필드도 같이)

    다시말하자면 static필드는 클래스가 로드되는 시점에 같이 로드가되고 프로그램이 종료되기전까지 죽지않고 살아있다.

    그렇다보니... static을 남발하는것은 메모리관리에 좋지않다. MethodArea는 GC의 대상이 아니므로 메모리관리가 되지않는다.

    HeapArea는 모든 인스턴스가 동적으로 생성되고, GC의 관리대상이다. MethodsArea에 저장되어있는 클래스 메타데이터를 이용해 객체를 생성한다.

    결론적으로 non-static 필드는 객체가 생성되는 시점에 필드가 생성되기때문에 (HeapArea에서) static과 생성과 소멸의 기간차이(?)가 있다.

    엄밀히말하자면 static은 프로그램이 종료되기전까진 불멸의 존재이고, non-static은 작성자가 인스턴스를 사용하지않으면 GC에 의해 제거된다.

    추가로 StackArea는 메서드를 호출하고나서 할당되는 지역변수가 들어오는 곳이다. 메서드 호출이 끝나면 자연스레 사라진다.

---

1. JIT 컴파일러
    ---


    저번주 TIL에서 JVM에대해 알아보았다. .java파일이 자바바이트코드로 변환되어 .class파일을 만들고 .class파일은 **JIT컴파일러**에의해 기계어로 변환된다.

    JIT 컴파일러를 알아보기전에 정적 컴파일러와 동적 컴파일러에대해 알아보자.

    정적 컴파일러의 대표적인 예시는 C언어이다.

    C언어는 실행시점 이전에 컴파일을 모두 마치고 런타임에는 컴파일을 하지않는다. 실행이전에 모든 컴파일과정을 거치기때문에 컴파일시간이 늘어난다는 장점이 있지만, 런타임시에는 컴파일하는 과정이 없기때문에 런타임성능은 뛰어나다.

    파이썬은 동적 컴파일러(인터프리터)를 사용하는 대표적인 언어다. 실행이전에 컴파일하지않기때문에 컴파일시간은 매우 짧지만 실행 후 컴파일을 하기때문에 런타임성능은 떨어질 수 밖에 없다.

    JIT컴파일러는 정적 컴파일러와 동적 컴파일러의 특성을 모두 가지고 있다.

    JVM은 초기에 인터프리터방식만을 사용했다. 즉 런타임시에 바이트코드를 한줄한줄 읽어서 바이너리코드로 변환했다. 런타임성능이 떨어지자 등장한 컴파일러가 JIT컴파일러다.

    JIT컴파일러는 우선 모든 바이트코드를 컴파일한 후에 JVM이 인터프리터방식으로 코드를 변환하면서 중복되는 코드들을 체크하고 해당 코드들은 캐싱하여 JIT컴파일러에게 실행을 맡긴다. 

    이렇게 JVM은 인터프리터방식과 중복되는 코드들을 캐싱하여 실행하는 방식을 채택하여 기존의 인터프리터방식만을 가지는 컴파일러보다는 좋은 성능을 가진다.

---

2. Integer Cache
    ---

    멘토님께서 신선한 충격을 주셨다.

    ```java
    Integer l1 = 100;
    Integer l2 = 100;

    Integer l3 = 200;
    Integer l4 = 200;

    if(l1 == l2){
        System.out.println("l1==l2");
    }
    if(l1.equals(l2)){
        System.out.println("l1.equals(l2)");
    }

    if(l3==l4){
        System.out.println("l3==l4");
    }
    if(l3.equals(l4)){
        System.out.println("l3.equals(l4)");
    }
    ```
        결과:l1==l2
            l1.equals(l2)
            l3.equals(l4)

    equlas 메서드는 값이 같은지를 boolean타입으로 반환한다.

    당연히 l1과l2의 값은 같고 l3와l4의 값도 같으니 결과의 두번째 세번째 줄은 이해가 간다.

    그런데 왜 l1==l2는 true지만 l3==l4는 false일까?

    이유를 알기위해선 Integer클래스가 값을 어떻게 저장하는지 알아야한다.

    ```java 
        public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
        }
    ```

    Integer l1 = 100; 으로 작성하면 위 valueOf메서드로 넘어가게된다.

    IntegerCache.low = -127 IntegerCache.hight = 128 로 정적멤버로 이루어져있다.

    즉 i의 값이 -127~128이면 캐시에 저장해놓고 재사용하게되고 그 이외의 값이 들어오면 객체를 새로생성해서 반환해준다.

    그래서 100을 할당한 l1,l2는 ==연산이 true지만 128을 넘는 200을 할당한 l3,l4는 false를 반환한다.

    이것을 Integer Cache라 부른다.

---

3. Object의 Equality 와 Identity
    ---
    Integer Cache를 알아보며 객체의 값이 동일한지 주소값이 동일한지 알아보았다.

    객체의 Equality는 Value(값)의 동일함을 뜻한다.

    객체의 Identity는 주소의 동일함을 뜻한다.

    ```java
        Integer a = new Integer(1);
        Integer b = new Integer(1);
    ```
    Equality에 따르면 a와 b는 같다. Value(1)가 같기때문이다.
    Identity에 따르면 두 객체는 다른 주소를 가지므로 같지 않다.

    >Integer Cache에 따르면 1은 Cache되야하는게 아닌가 의문을 가질 수 있겠지만, 위 코드는 new연산자를 사용해서 인스턴스를 새롭게 생성했기때문에 캐시되지않는다.

    ```java 
        Integer a = new Integer(1);
        Integer b = a;
    ```
    이 경우엔 어떨까? a와b의 값도같고 주소도 같다.

    정리하자면 Identity는 Equality를 보장하지만 Equality는 Identity를 보장하지 않는다.

4. Checked Exception & Unchecked Exception
    ---
    Exception클래스를 상속받는 클래스 중에서 Runtime Exception을 포함한 하위클래스를 Unchecked Exception이라고한다.

    Unchecked Exception 실행시 발생하는 예외로 예외처리를 강요하지않는다. 만약 예외가 발생할 수 있는 모든 경우에대해 예외처리를 강요하게되면 개발자들은 배열하나를 사용하는데도 예외처리를 해주어야된다...

    그에 반해 Checked Exception은 예외처리가 필수적이다. 컴파일 단계에서부터 예외처리를 강요해서 컴파일전부터 개발자는 예외처리를 해주어야한다.

    그리고 또 한가지 차이점은 Checked Exception은 롤백하지않고 Unchecked Exception은 롤백한다는 점이다.

    롤백이란 수행된 작업을 반영하지않는것을 말한다.


