## 연산 횟수

기본적으로 1초에 1억번 연산을 기준으로 한다.

시간복잡도는 항상 최악을 기준으로 !

채점할 때 절대 한 가지 케이스로 검증하지않는다.

## next() nextLine()

nextLine은 '\n'을 포함하는 한 라인을 읽고 \n을 버린다.

next는 \n을 제외하고 가져온다.

> 공백, 개행 모두

> nextInt nextDouble 모두 next와 똑같다.

## BufferedReader BufferedWriter

둘 다 버퍼를 이용해 데이터를 전달한다.

> Scanner는 버퍼를 이용하지 않는다.

일반적인 scanner 나 sout 보다 빠르다.

많은 양의 데이터를 입력받거나 출력할 때 사용한다.

StringTokenizer와 함께 사용하는데 readLine()이 공백을 기준으로 토큰화 시키고 개행전까지 입력받는다.

StirngTokenizer엔 토큰이 공백 기준으로 잘려서 들어가있다.

## 구간 합 알고리즘

주어진 배열의 누적합을 새로운 배열에 담아서 문제를 해결하는 방법이다.

일반적인 방법으로 일정 범위의 구간 합을 구하면 시간 복잡도는 O(N)이다.

하지만 구간합 배열을 생성하면 O(1)이된다.

> 이미 생성해놓았기 때문에

## 나머지 구하기

(A+B)%M = (A%M + B%M)%M

음수도 마찬가지로 해당된다.

## 투 포인터

두 개의 포인터를 이용해 시간 복잡도를 낮추는 알고리즘이다.

보통 문제마다 두 개의 포인터를 어떻게 이동하는 규칙을 만드는지가 중요한 것 같다.

> 이 규칙을 적용하기위해선 정렬은 필수다.
> Target 값보다 작냐 크냐를 기준으로 규칙을 만들어야한다.

투 포인터의 시간복잡도는 O(N)이다.

> 일반적으로 O(n^2) > O(nlogn) > O(n) > O(1)

## 두 용액 2470, 수 고르기 2230

투 포인터를 이용해 푸는 문제였는데 역시나 포인터를 움직이는 규칙을 잘 못찾았다.

두 문제를 풀고나서 보니 포인터를 움직이는 규칙은 어떠한 기준이 필요하다.

기준을 잡고 양쪽 포인터 중 어느 포인터를 증가시키고 감소시킬지가 중요하다.

그리고 그 기준을 비교할 변수를 계속해서 갱신해야한다.

> 두 용액의 경우 sum, 수 고르기의 경우 두 수의 차이


---

BufferedReader BufferedWriter StringBuilder

VS 

Scanner 취향 차이

ArrayList VS Array (ArrayList가 라이브러리가 많다.)

누적합 [시간 복잡도를 줄인다. O(N^2) -> O(N)으로]

